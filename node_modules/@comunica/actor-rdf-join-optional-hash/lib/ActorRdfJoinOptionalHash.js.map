{"version":3,"file":"ActorRdfJoinOptionalHash.js","sourceRoot":"","sources":["ActorRdfJoinOptionalHash.ts"],"names":[],"mappings":"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","sourcesContent":["import { ClosableTransformIterator } from '@comunica/bus-query-operation';\nimport { ActorRdfJoin } from '@comunica/bus-rdf-join';\nimport type {\n  IActionRdfJoin,\n  IActorRdfJoinArgs,\n  IActorRdfJoinOutputInner,\n} from '@comunica/bus-rdf-join';\nimport type { IMediatorTypeJoinCoefficients } from '@comunica/mediatortype-join-coefficients';\nimport type { BindingsStream, MetadataBindings } from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { UnionIterator, ArrayIterator, MultiTransformIterator, BufferedIterator } from 'asynciterator';\nimport { termToString } from 'rdf-string';\nimport { BindingsIndexDef } from './BindingsIndexDef';\nimport { BindingsIndexUndef } from './BindingsIndexUndef';\nimport type { IBindingsIndex } from './IBindingsIndex';\n\n/**\n * A comunica Optional Hash RDF Join Actor.\n */\nexport class ActorRdfJoinOptionalHash extends ActorRdfJoin {\n  private readonly blocking: boolean;\n\n  public constructor(args: IActorRdfJoinOptionalHashArgs) {\n    super(args, {\n      logicalType: 'optional',\n      physicalName: `hash-${args.canHandleUndefs ? 'undef' : 'def'}-${args.blocking ? 'blocking' : 'nonblocking'}`,\n      limitEntries: 2,\n      canHandleUndefs: args.canHandleUndefs,\n      requiresVariableOverlap: true,\n    });\n  }\n\n  public static constructIndex<V>(undef: boolean, commonVariables: RDF.Variable[]): IBindingsIndex<V> {\n    return undef ?\n      new BindingsIndexUndef(\n        commonVariables,\n        (term: RDF.Term | undefined) => term && term.termType !== 'Variable' ? termToString(term) : '',\n      ) :\n      new BindingsIndexDef(commonVariables, ActorRdfJoin.hashNonClashing);\n  }\n\n  public async getOutput(action: IActionRdfJoin): Promise<IActorRdfJoinOutputInner> {\n    const buffer = action.entries[1].output;\n    const output = action.entries[0].output;\n\n    const metadatas = await ActorRdfJoin.getMetadatas(action.entries);\n    const commonVariables: RDF.Variable[] = ActorRdfJoin.overlappingVariables(metadatas);\n\n    let bindingsStream: BindingsStream;\n    if (this.blocking) {\n      // -- Blocking optional ---\n\n      bindingsStream = new ClosableTransformIterator(async() => {\n        // We index all bindings from the right-hand OPTIONAL iterator first in a blocking manner.\n        const index: IBindingsIndex<RDF.Bindings[]> = ActorRdfJoinOptionalHash\n          .constructIndex(this.canHandleUndefs, commonVariables);\n        await new Promise((resolve) => {\n          buffer.bindingsStream.on('data', (bindings) => {\n            const iterator = index.getFirst(bindings) ?? index.put(bindings, []);\n            iterator.push(bindings);\n          });\n          buffer.bindingsStream.on('end', resolve);\n          buffer.bindingsStream.on('error', (error) => {\n            bindingsStream.emit('error', error);\n          });\n        });\n\n        // Start our left-hand iterator and try to join with the index\n        return new MultiTransformIterator(\n          output.bindingsStream,\n          {\n            multiTransform: (bindings: RDF.Bindings): AsyncIterator<RDF.Bindings> => new ArrayIterator<RDF.Bindings>(\n              <RDF.Bindings[]>(index.get(bindings).flat())\n                .map(indexBindings => ActorRdfJoin.joinBindings(bindings, indexBindings))\n                .filter(b => b !== null),\n              { autoStart: false },\n            ),\n            optional: true,\n            autoStart: false,\n          },\n        );\n      }, {\n        autoStart: false,\n        onClose() {\n          buffer.bindingsStream.destroy();\n          output.bindingsStream.destroy();\n        },\n      });\n    } else {\n      // -- Non-blocking optional ---\n      // This can be slightly slower than the blocking one above, due to the streaming overhead.\n\n      bindingsStream = new ClosableTransformIterator(async() => {\n        // We index all bindings from the right-hand OPTIONAL iterator.\n        // They are indexed with iterator values, so our main stream can already get started.\n        const index: IBindingsIndex<BufferedIterator<RDF.Bindings>> = ActorRdfJoinOptionalHash\n          .constructIndex(this.canHandleUndefs, commonVariables);\n        let indexActive = true;\n        buffer.bindingsStream.on('data', (bindings) => {\n          const iterator = index.getFirst(bindings) ??\n            index.put(bindings, new BufferedIterator<RDF.Bindings>({ autoStart: false }));\n          (<any> iterator)._push(bindings);\n        });\n        buffer.bindingsStream.on('end', () => {\n          for (const iterator of index.values()) {\n            iterator.close();\n          }\n          indexActive = false;\n        });\n        buffer.bindingsStream.on('error', (error) => {\n          bindingsStream.emit('error', error);\n        });\n\n        // Start our left-hand iterator and try to join with the index\n        return new MultiTransformIterator(\n          output.bindingsStream,\n          {\n            multiTransform: (bindings: RDF.Bindings): AsyncIterator<RDF.Bindings> => {\n              // Find iterators from the index\n              let iterators: AsyncIterator<RDF.Bindings>[] = index.get(bindings);\n\n              // If no index entry was found, set an empty iterator.\n              // If we index has been closed already, don't modify the index, but just use an empty dummy iterator.\n              if (iterators.length === 0) {\n                if (indexActive) {\n                  iterators = [ index.put(bindings, new BufferedIterator<RDF.Bindings>({ autoStart: false })) ];\n                } else {\n                  iterators = [];\n                }\n              }\n\n              // Merge all iterators in a single one,\n              // and clone each one to make sure we can still use them in the future.\n              const iterator = new UnionIterator<RDF.Bindings>(iterators.map(it => it.clone()), { autoStart: false });\n              return iterator.map(indexBindings => ActorRdfJoin.joinBindings(bindings, indexBindings));\n            },\n            optional: true,\n            autoStart: false,\n          },\n        );\n      }, {\n        autoStart: false,\n        onClose() {\n          buffer.bindingsStream.destroy();\n          output.bindingsStream.destroy();\n        },\n      });\n    }\n\n    return {\n      result: {\n        type: 'bindings',\n        bindingsStream,\n        metadata: async() => await this.constructResultMetadata(\n          action.entries,\n          await ActorRdfJoin.getMetadatas(action.entries),\n          action.context,\n          { canContainUndefs: true },\n          true,\n        ),\n      },\n    };\n  }\n\n  protected async getJoinCoefficients(\n    action: IActionRdfJoin,\n    metadatas: MetadataBindings[],\n  ): Promise<IMediatorTypeJoinCoefficients> {\n    const requestInitialTimes = ActorRdfJoin.getRequestInitialTimes(metadatas);\n    const requestItemTimes = ActorRdfJoin.getRequestItemTimes(metadatas);\n    let iterations = metadatas[0].cardinality.value + metadatas[1].cardinality.value;\n    if (!this.canHandleUndefs) {\n      // Our non-undef implementation is slightly more performant.\n      iterations *= 0.8;\n    }\n    if (this.blocking) {\n      // Our blocking implementation is slightly more performant.\n      iterations *= 0.9;\n    }\n    return {\n      iterations,\n      persistedItems: metadatas[0].cardinality.value,\n      blockingItems: this.blocking ? metadatas[0].cardinality.value : 0,\n      requestTime: requestInitialTimes[0] + metadatas[0].cardinality.value * requestItemTimes[0] +\n        requestInitialTimes[1] + metadatas[1].cardinality.value * requestItemTimes[1],\n    };\n  }\n}\n\nexport interface IActorRdfJoinOptionalHashArgs extends IActorRdfJoinArgs {\n  /**\n   * If this actor can handle undefined values.\n   * If false, performance will be slightly better.\n   */\n  canHandleUndefs: boolean;\n  /**\n   * If the join will block when collecting the optional stream.\n   * If true, performance will be better.\n   */\n  blocking: boolean;\n}\n"]}