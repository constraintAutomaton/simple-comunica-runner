"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BindingsIndexUndef = void 0;
/**
 * A simple efficient tree-based index for maintaining bindings,
 * and checking whether or not a bindings is contained in this index.
 *
 * This will consider bindings with a variable term or an undefined term
 * as a 'match-all' with other terms.
 */
class BindingsIndexUndef {
    constructor(keys, hashFn) {
        this.data = {};
        this.keys = keys;
        this.hashFn = hashFn;
    }
    /**
     * Add the given bindings to the index.
     * @param {Bindings} bindings A bindings.
     * @param {V} value The value to put.
     */
    put(bindings, value) {
        if (this.isBindingsValid(bindings)) {
            let dataIt = this.data;
            for (let i = 0; i < this.keys.length; i++) {
                const key = this.keys[i];
                const dataKey = this.hashFn(bindings.get(key));
                let subDataIt = dataIt[dataKey];
                if (!subDataIt) {
                    subDataIt = dataIt[dataKey] = i === this.keys.length - 1 ? value : {};
                }
                dataIt = subDataIt;
            }
        }
        return value;
    }
    isBindingsValid(bindings) {
        let validKeys = false;
        for (const key of this.keys) {
            if (bindings.has(key)) {
                validKeys = true;
                break;
            }
        }
        return validKeys;
    }
    /**
     * Get the value of the given bindings is contained in this index.
     * @param {Bindings} bindings A bindings.
     * @return {V[]} The values.
     */
    get(bindings) {
        // Always return undefined if the bindings contain none of the expected keys
        if (!this.isBindingsValid(bindings)) {
            return [];
        }
        return this.getRecursive(bindings, this.keys, [this.data]);
    }
    getRecursive(bindings, keys, dataIndexes) {
        if (keys.length === 0) {
            return dataIndexes;
        }
        let key;
        // eslint-disable-next-line prefer-const
        [key, ...keys] = keys;
        const matchingRecursive = [];
        for (const data of dataIndexes) {
            // If the index contained a variable, all terms will match.
            const dataKey = this.hashFn(bindings?.get(key));
            if (dataKey) {
                // Check the entry for the term, and the variable term.
                const subDatas = [data[dataKey], data['']].filter(Boolean);
                if (subDatas.length === 0) {
                    continue;
                }
                matchingRecursive.push(this.getRecursive(bindings, keys, subDatas));
            }
            else {
                // Iterate over all entries
                const subDatas = Object.values(data);
                if (subDatas.length === 0) {
                    continue;
                }
                matchingRecursive.push(this.getRecursive(bindings, keys, subDatas));
            }
        }
        return matchingRecursive.flat();
    }
    /**
     * Get the first value of the given bindings is contained in this index.
     * @param {Bindings} bindings A bindings.
     * @return {V | undefined} The value.
     */
    getFirst(bindings) {
        // Always return undefined if the bindings contain none of the expected keys
        if (!this.isBindingsValid(bindings)) {
            return undefined;
        }
        return this.getRecursiveFirst(bindings, this.keys, [this.data]);
    }
    getRecursiveFirst(bindings, keys, dataIndexes) {
        if (keys.length === 0) {
            return dataIndexes[0];
        }
        let key;
        // eslint-disable-next-line prefer-const
        [key, ...keys] = keys;
        for (const data of dataIndexes) {
            // If the index contained a variable, all terms will match.
            const dataKey = this.hashFn(bindings.get(key));
            if (dataKey) {
                // Check the entry for the term, and the variable term.
                const subDatas = [data[dataKey], data['']].filter(Boolean);
                if (subDatas.length === 0) {
                    continue;
                }
                const ret = this.getRecursiveFirst(bindings, keys, subDatas);
                if (ret) {
                    return ret;
                }
            }
            else {
                // Iterate over all entries
                const subDatas = Object.values(data);
                if (subDatas.length === 0) {
                    continue;
                }
                const ret = this.getRecursiveFirst(bindings, keys, subDatas);
                if (ret) {
                    return ret;
                }
            }
        }
        return undefined;
    }
    values() {
        return this.keys.length === 0 ? [] : this.getRecursive(undefined, this.keys, [this.data]);
    }
}
exports.BindingsIndexUndef = BindingsIndexUndef;
//# sourceMappingURL=BindingsIndexUndef.js.map