{"version":3,"file":"ClosableIterator.js","sourceRoot":"","sources":["ClosableIterator.ts"],"names":[],"mappings":";;;AAAA,iDAA2D;AAK3D;;;GAGG;AACH,MAAa,gBAAoB,SAAQ,6BAAgB;IAIvD,YAAmB,MAAwB,EAAE,OAAgC;QAC3E,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC;QAC/B,IAAI,CAAC,OAAO,GAAuB,MAAM,CAAC;QAE1C,iCAAiC;QACjC,IAAI,CAAC,OAAO,CAAC,2BAAW,CAAC,GAAG,IAAI,CAAC;QACjC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAC;QACzC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,oBAAoB,CAAC,CAAC;QAC/C,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,UAAU,EAAE,sBAAsB,CAAC,CAAC;QACpD,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC;IACxC,CAAC;IAEe,IAAI;QAClB,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;QAChC,IAAI,CAAC,GAAG,EAAE,CAAC;YACT,uCAAuC;YACvC,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;YAEtB,6CAA6C;YAC7C,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;gBACtB,IAAI,CAAC,KAAK,EAAE,CAAC;YACf,CAAC;QACH,CAAC;QACD,OAAO,GAAG,CAAC;IACb,CAAC;IAEkB,IAAI,CAAC,OAAgB;QACtC,IAAI,CAAC,OAAO,EAAE,CAAC;QAEf,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAAC;QACrD,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,OAAO,EAAE,oBAAoB,CAAC,CAAC;QAC3D,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,UAAU,EAAE,sBAAsB,CAAC,CAAC;QAChE,OAAO,IAAI,CAAC,OAAO,CAAC,2BAAW,CAAC,CAAC;QACjC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;QACvB,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IACtB,CAAC;CACF;AAzCD,4CAyCC;AAED,oFAAoF;AAEpF,SAAS,sBAAsB;IAC7B,IAAI,CAAC,2BAAW,CAAE,CAAC,QAAQ,GAAG,IAAI,CAAC;AACrC,CAAC;AACD,SAAS,oBAAoB,CAA6B,KAAY;IACpE,IAAI,CAAC,2BAAW,CAAE,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC;AAC1C,CAAC;AACD,SAAS,gBAAgB;IACvB,IAAI,CAAC,2BAAW,CAAE,CAAC,KAAK,EAAE,CAAC;AAC7B,CAAC","sourcesContent":["import { AsyncIterator, DESTINATION } from 'asynciterator';\n\ntype InternalSource<T> =\n  AsyncIterator<T> & { [DESTINATION]?: AsyncIterator<any> };\n\n/**\n * An AsyncIterator with a callback for when this iterator is closed in any way.\n * In contrast to ClosableTransformIterator, this does not add the overhead of a TransformIterator.\n */\nexport class ClosableIterator<S> extends AsyncIterator<S> {\n  protected readonly _source: InternalSource<S>;\n  private readonly onClose: () => void;\n\n  public constructor(source: AsyncIterator<S>, options: { onClose: () => void }) {\n    super();\n    this.onClose = options.onClose;\n    this._source = <InternalSource<S>> source;\n\n    // Wire up the source for reading\n    this._source[DESTINATION] = this;\n    this._source.on('end', destinationClose);\n    this._source.on('error', destinationEmitError);\n    this._source.on('readable', destinationSetReadable);\n    this.readable = this._source.readable;\n  }\n\n  public override read(): S | null {\n    const ret = this._source.read();\n    if (!ret) {\n      // Mark as non-readable if ret was null\n      this.readable = false;\n\n      // Close this iterator if the source is empty\n      if (this._source.done) {\n        this.close();\n      }\n    }\n    return ret;\n  }\n\n  protected override _end(destroy: boolean): void {\n    this.onClose();\n\n    this._source.removeListener('end', destinationClose);\n    this._source.removeListener('error', destinationEmitError);\n    this._source.removeListener('readable', destinationSetReadable);\n    delete this._source[DESTINATION];\n    this._source.destroy();\n    super._end(destroy);\n  }\n}\n\n// Helpers below are copied from AsyncIterator, as they are not exported from there.\n\nfunction destinationSetReadable<S>(this: InternalSource<S>): void {\n  this[DESTINATION]!.readable = true;\n}\nfunction destinationEmitError<S>(this: InternalSource<S>, error: Error): void {\n  this[DESTINATION]!.emit('error', error);\n}\nfunction destinationClose<S>(this: InternalSource<S>): void {\n  this[DESTINATION]!.close();\n}\n"]}