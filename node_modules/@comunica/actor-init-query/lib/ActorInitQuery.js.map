{"version":3,"file":"ActorInitQuery.js","sourceRoot":"","sources":["ActorInitQuery.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable import/no-nodejs-modules */\nimport { readFileSync } from 'node:fs';\nimport type { IActionInit, IActorOutputInit } from '@comunica/bus-init';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport type { ICliArgsHandler, IQueryContextCommon } from '@comunica/types';\nimport { Readable } from 'readable-stream';\nimport yargs from 'yargs';\nimport type { IActorInitQueryBaseArgs } from './ActorInitQueryBase';\nimport { ActorInitQueryBase } from './ActorInitQueryBase';\nimport { CliArgsHandlerBase } from './cli/CliArgsHandlerBase';\nimport { CliArgsHandlerQuery } from './cli/CliArgsHandlerQuery';\nimport { QueryEngineBase } from './QueryEngineBase';\n\n/**\n * A comunica Query Init Actor.\n */\nexport class ActorInitQuery<QueryContext extends IQueryContextCommon = IQueryContextCommon> extends ActorInitQueryBase {\n  public constructor(args: IActorInitQueryBaseArgs) {\n    super(args);\n  }\n\n  public override async run(action: IActionInit): Promise<IActorOutputInit> {\n    // Wrap this actor in a query engine so we can conveniently execute queries\n    const queryEngine = new QueryEngineBase<QueryContext>(this);\n\n    const cliArgsHandlers: ICliArgsHandler[] = [\n      new CliArgsHandlerBase(action.context),\n      new CliArgsHandlerQuery(\n        this.defaultQueryInputFormat,\n        this.queryString,\n        this.context,\n        this.allowNoSources,\n      ),\n      ...(<ICliArgsHandler[]> action.context?.get(KeysInitQuery.cliArgsHandlers)) || [],\n    ];\n\n    // Populate yargs arguments object\n    let argumentsBuilder = yargs([]);\n    for (const cliArgsHandler of cliArgsHandlers) {\n      argumentsBuilder = cliArgsHandler.populateYargs(argumentsBuilder);\n    }\n\n    // Extract raw argument values from parsed yargs object, so that we can handle each of them hereafter\n    let args: Record<string, any>;\n    try {\n      args = await argumentsBuilder.parse(action.argv);\n    } catch (error: unknown) {\n      return {\n        stderr: Readable.from([ `${await argumentsBuilder.getHelp()}\\n\\n${(<Error> error).message}\\n` ]),\n      };\n    }\n\n    // Print supported MIME types\n    if (args.listformats) {\n      const mediaTypes: Record<string, number> = await queryEngine.getResultMediaTypes();\n      return { stdout: Readable.from([ `${Object.keys(mediaTypes).join('\\n')}\\n` ]) };\n    }\n\n    // Define query\n    // We need to do this before the cliArgsHandlers, as we may modify the sources array\n    let query: string | undefined;\n    if (args.query) {\n      query = <string> args.query;\n    } else if (args.file) {\n      query = readFileSync(args.file, { encoding: 'utf8' });\n    } else if (args.sources.length > 0) {\n      query = args.sources.at(-1);\n      args.sources.pop();\n    }\n\n    // Invoke args handlers to process any remaining args\n    const context: Record<string, any> = {};\n    try {\n      for (const cliArgsHandler of cliArgsHandlers) {\n        await cliArgsHandler.handleArgs(args, context);\n      }\n    } catch (error: unknown) {\n      return { stderr: Readable.from([ (<Error> error).message ]) };\n    }\n\n    // Evaluate query\n    const queryResult = await queryEngine.queryOrExplain(query!, <any> context);\n\n    // Output query explanations in a different way\n    if ('explain' in queryResult) {\n      return {\n        stdout: Readable.from([ typeof queryResult.data === 'string' ?\n          // eslint-disable-next-line prefer-template\n          queryResult.data + '\\n' :\n          // eslint-disable-next-line prefer-template\n          JSON.stringify(queryResult.data, (key: string, value: any) => {\n            if (key === 'scopedSource') {\n              return value.source.toString();\n            }\n            return value;\n          }, '  ') + '\\n' ]),\n      };\n    }\n\n    // Serialize output according to media type\n    const stdout: Readable = <Readable> (await queryEngine.resultToString(\n      queryResult,\n      args.outputType,\n      queryResult.context,\n    )).data;\n\n    return { stdout };\n  }\n}\n/* eslint-enable import/no-nodejs-modules */\n"]}