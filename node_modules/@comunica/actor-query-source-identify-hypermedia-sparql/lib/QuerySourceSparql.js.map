{"version":3,"file":"QuerySourceSparql.js","sourceRoot":"","sources":["QuerySourceSparql.ts"],"names":[],"mappings":"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","sourcesContent":["import type { BindingsFactory } from '@comunica/bindings-factory';\nimport type { MediatorHttp } from '@comunica/bus-http';\nimport { KeysInitQuery } from '@comunica/context-entries';\nimport { Actor } from '@comunica/core';\nimport { MetadataValidationState } from '@comunica/metadata';\nimport type {\n  IQuerySource,\n  BindingsStream,\n  IActionContext,\n  FragmentSelectorShape,\n  Bindings,\n  MetadataBindings,\n  IQueryBindingsOptions,\n} from '@comunica/types';\nimport type * as RDF from '@rdfjs/types';\nimport type { AsyncIterator } from 'asynciterator';\nimport { wrap, TransformIterator } from 'asynciterator';\nimport { SparqlEndpointFetcher } from 'fetch-sparql-endpoint';\nimport { LRUCache } from 'lru-cache';\nimport { DataFactory } from 'rdf-data-factory';\nimport { Algebra, Factory, toSparql, Util } from 'sparqlalgebrajs';\nimport type { BindMethod } from './ActorQuerySourceIdentifyHypermediaSparql';\n\nconst AF = new Factory();\nconst DF = new DataFactory<RDF.BaseQuad>();\nconst VAR_COUNT = DF.variable('count');\nconst COUNT_INFINITY: RDF.QueryResultCardinality = { type: 'estimate', value: Number.POSITIVE_INFINITY };\n\nexport class QuerySourceSparql implements IQuerySource {\n  protected static readonly SELECTOR_SHAPE: FragmentSelectorShape = {\n    type: 'disjunction',\n    children: [\n      {\n        type: 'operation',\n        operation: { operationType: 'type', type: Algebra.types.PROJECT },\n        joinBindings: true,\n      },\n      {\n        type: 'operation',\n        operation: { operationType: 'type', type: Algebra.types.CONSTRUCT },\n      },\n      {\n        type: 'operation',\n        operation: { operationType: 'type', type: Algebra.types.DESCRIBE },\n      },\n      {\n        type: 'operation',\n        operation: { operationType: 'type', type: Algebra.types.ASK },\n      },\n      {\n        type: 'operation',\n        operation: { operationType: 'type', type: Algebra.types.COMPOSITE_UPDATE },\n      },\n    ],\n  };\n\n  public readonly referenceValue: string;\n  private readonly url: string;\n  private readonly context: IActionContext;\n  private readonly mediatorHttp: MediatorHttp;\n  private readonly bindMethod: BindMethod;\n  private readonly countTimeout: number;\n  private readonly bindingsFactory: BindingsFactory;\n\n  private readonly endpointFetcher: SparqlEndpointFetcher;\n  private readonly cache: LRUCache<string, RDF.QueryResultCardinality> | undefined;\n\n  private lastSourceContext: IActionContext | undefined;\n\n  public constructor(\n    url: string,\n    context: IActionContext,\n    mediatorHttp: MediatorHttp,\n    bindMethod: BindMethod,\n    bindingsFactory: BindingsFactory,\n    forceHttpGet: boolean,\n    cacheSize: number,\n    countTimeout: number,\n  ) {\n    this.referenceValue = url;\n    this.url = url;\n    this.context = context;\n    this.mediatorHttp = mediatorHttp;\n    this.bindMethod = bindMethod;\n    this.bindingsFactory = bindingsFactory;\n    this.endpointFetcher = new SparqlEndpointFetcher({\n      method: forceHttpGet ? 'GET' : 'POST',\n      fetch: (input: Request | string, init?: RequestInit) => this.mediatorHttp.mediate(\n        { input, init, context: this.lastSourceContext! },\n      ),\n      prefixVariableQuestionMark: true,\n    });\n    this.cache = cacheSize > 0 ?\n      new LRUCache<string, RDF.QueryResultCardinality>({ max: cacheSize }) :\n      undefined;\n    this.countTimeout = countTimeout;\n  }\n\n  public async getSelectorShape(): Promise<FragmentSelectorShape> {\n    return QuerySourceSparql.SELECTOR_SHAPE;\n  }\n\n  public queryBindings(\n    operationIn: Algebra.Operation,\n    context: IActionContext,\n    options?: IQueryBindingsOptions,\n  ): BindingsStream {\n    // If bindings are passed, modify the operations\n    let operationPromise: Promise<Algebra.Operation>;\n    if (options?.joinBindings) {\n      operationPromise = QuerySourceSparql.addBindingsToOperation(this.bindMethod, operationIn, options.joinBindings);\n    } else {\n      operationPromise = Promise.resolve(operationIn);\n    }\n\n    const bindings: BindingsStream = new TransformIterator(async() => {\n      // Prepare queries\n      const operation = await operationPromise;\n      const variables: RDF.Variable[] = Util.inScopeVariables(operation);\n      const queryString = context.get<string>(KeysInitQuery.queryString);\n      const selectQuery: string = !options?.joinBindings && queryString ?\n        queryString :\n        QuerySourceSparql.operationToSelectQuery(operation, variables);\n      const canContainUndefs = QuerySourceSparql.operationCanContainUndefs(operation);\n\n      return this.queryBindingsRemote(this.url, selectQuery, variables, context, canContainUndefs);\n    }, { autoStart: false });\n    this.attachMetadata(bindings, context, operationPromise);\n\n    return bindings;\n  }\n\n  public queryQuads(operation: Algebra.Operation, context: IActionContext): AsyncIterator<RDF.Quad> {\n    this.lastSourceContext = this.context.merge(context);\n    const rawStream = this.endpointFetcher.fetchTriples(\n      this.url,\n      context.get(KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation),\n    );\n    this.lastSourceContext = undefined;\n    const quads = wrap<any>(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY });\n    this.attachMetadata(quads, context, Promise.resolve(operation.input));\n    return quads;\n  }\n\n  public queryBoolean(operation: Algebra.Ask, context: IActionContext): Promise<boolean> {\n    this.lastSourceContext = this.context.merge(context);\n    const promise = this.endpointFetcher.fetchAsk(\n      this.url,\n      context.get(KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation),\n    );\n    this.lastSourceContext = undefined;\n    return promise;\n  }\n\n  public queryVoid(operation: Algebra.Update, context: IActionContext): Promise<void> {\n    this.lastSourceContext = this.context.merge(context);\n    const promise = this.endpointFetcher.fetchUpdate(\n      this.url,\n      context.get(KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation),\n    );\n    this.lastSourceContext = undefined;\n    return promise;\n  }\n\n  protected attachMetadata(\n    target: AsyncIterator<any>,\n    context: IActionContext,\n    operationPromise: Promise<Algebra.Operation>,\n  ): void {\n    // Emit metadata containing the estimated count\n    let variablesCount: RDF.Variable[] = [];\n    let canContainUndefs = false;\n    // eslint-disable-next-line no-async-promise-executor,ts/no-misused-promises\n    new Promise<RDF.QueryResultCardinality>(async(resolve, reject) => {\n      // Prepare queries\n      let countQuery: string;\n      try {\n        const operation = await operationPromise;\n        variablesCount = Util.inScopeVariables(operation);\n        countQuery = QuerySourceSparql.operationToCountQuery(operation);\n        canContainUndefs = QuerySourceSparql.operationCanContainUndefs(operation);\n\n        const cachedCardinality = this.cache?.get(countQuery);\n        if (cachedCardinality !== undefined) {\n          return resolve(cachedCardinality);\n        }\n\n        const timeoutHandler = setTimeout(() => resolve(COUNT_INFINITY), this.countTimeout);\n        const bindingsStream: BindingsStream = await this\n          .queryBindingsRemote(this.url, countQuery, [ VAR_COUNT ], context, false);\n        bindingsStream.on('data', (bindings: Bindings) => {\n          clearTimeout(timeoutHandler);\n          const count = bindings.get(VAR_COUNT);\n          const cardinality: RDF.QueryResultCardinality = { type: 'estimate', value: Number.POSITIVE_INFINITY };\n          if (count) {\n            const cardinalityValue: number = Number.parseInt(count.value, 10);\n            if (!Number.isNaN(cardinalityValue)) {\n              cardinality.type = 'exact';\n              cardinality.value = cardinalityValue;\n              this.cache?.set(countQuery, cardinality);\n            }\n          }\n          return resolve(cardinality);\n        });\n        bindingsStream.on('error', () => {\n          clearTimeout(timeoutHandler);\n          resolve(COUNT_INFINITY);\n        });\n        bindingsStream.on('end', () => {\n          clearTimeout(timeoutHandler);\n          resolve(COUNT_INFINITY);\n        });\n      } catch (error: unknown) {\n        return reject(error);\n      }\n    })\n      .then((cardinality) => {\n        target.setProperty('metadata', {\n          state: new MetadataValidationState(),\n          cardinality,\n          canContainUndefs,\n          variables: variablesCount,\n        });\n      })\n      .catch(() => target.setProperty('metadata', {\n        state: new MetadataValidationState(),\n        cardinality: COUNT_INFINITY,\n        canContainUndefs,\n        variables: variablesCount,\n      }));\n  }\n\n  /**\n   * Create an operation that includes the bindings from the given bindings stream.\n   * @param bindMethod A method for adding bindings to an operation.\n   * @param operation The operation to bind to.\n   * @param addBindings The bindings to add.\n   * @param addBindings.bindings The bindings stream.\n   * @param addBindings.metadata The bindings metadata.\n   */\n  public static async addBindingsToOperation(\n    bindMethod: BindMethod,\n    operation: Algebra.Operation,\n    addBindings: { bindings: BindingsStream; metadata: MetadataBindings },\n  ): Promise<Algebra.Operation> {\n    const bindings = await addBindings.bindings.toArray();\n\n    switch (bindMethod) {\n      case 'values':\n        return AF.createJoin([\n          AF.createValues(\n            addBindings.metadata.variables,\n            bindings.map(binding => Object.fromEntries([ ...binding ]\n              .map(([ key, value ]) => [ `?${key.value}`, <RDF.Literal | RDF.NamedNode> value ]))),\n          ),\n          operation,\n        ], false);\n      case 'union': { throw new Error('Not implemented yet: \"union\" case'); }\n      case 'filter': { throw new Error('Not implemented yet: \"filter\" case'); }\n    }\n  }\n\n  /**\n   * Convert an operation to a select query for this pattern.\n   * @param {Algebra.Operation} operation A query operation.\n   * @param {RDF.Variable[]} variables The variables in scope for the operation.\n   * @return {string} A select query string.\n   */\n  public static operationToSelectQuery(operation: Algebra.Operation, variables: RDF.Variable[]): string {\n    return QuerySourceSparql.operationToQuery(AF.createProject(operation, variables));\n  }\n\n  /**\n   * Convert an operation to a count query for the number of matching triples for this pattern.\n   * @param {Algebra.Operation} operation A query operation.\n   * @return {string} A count query string.\n   */\n  public static operationToCountQuery(operation: Algebra.Operation): string {\n    return QuerySourceSparql.operationToQuery(AF.createProject(\n      AF.createExtend(\n        AF.createGroup(\n          operation,\n          [],\n          [ AF.createBoundAggregate(\n            DF.variable('var0'),\n            'count',\n            AF.createWildcardExpression(),\n            false,\n          ) ],\n        ),\n        DF.variable('count'),\n        AF.createTermExpression(DF.variable('var0')),\n      ),\n      [ DF.variable('count') ],\n    ));\n  }\n\n  /**\n   * Convert an operation to a query for this pattern.\n   * @param {Algebra.Operation} operation A query operation.\n   * @return {string} A query string.\n   */\n  public static operationToQuery(operation: Algebra.Operation): string {\n    return toSparql(operation, { sparqlStar: true });\n  }\n\n  /**\n   * Check if the given operation may produce undefined values.\n   * @param operation\n   */\n  public static operationCanContainUndefs(operation: Algebra.Operation): boolean {\n    let canContainUndefs = false;\n    Util.recurseOperation(operation, {\n      leftjoin(): boolean {\n        canContainUndefs = true;\n        return false;\n      },\n      values(values: Algebra.Values): boolean {\n        canContainUndefs = values.bindings.some(bindings => values.variables.some(variable => !(`?${variable.value}` in bindings)));\n        return false;\n      },\n      union(union: Algebra.Union): boolean {\n        // Determine variables in scope of the union branches\n        const scopedVariables = union.input\n          .map(Util.inScopeVariables)\n          .map(variables => variables.map(v => v.value))\n          .map(variables => variables.sort((a, b) => a.localeCompare(b)))\n          .map(variables => variables.join(','));\n\n        // If not all scoped variables in union branches are equal, then we definitely can have undefs\n        if (!scopedVariables.every(val => val === scopedVariables[0])) {\n          canContainUndefs = true;\n          return false;\n        }\n\n        return true;\n      },\n    });\n    return canContainUndefs;\n  }\n\n  /**\n   * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.\n   * @param {string} endpoint A SPARQL endpoint URL.\n   * @param {string} query A SPARQL query string.\n   * @param {RDF.Variable[]} variables The expected variables.\n   * @param {IActionContext} context The source context.\n   * @param canContainUndefs If the operation may contain undefined variables.\n   * @return {BindingsStream} A stream of bindings.\n   */\n  public async queryBindingsRemote(\n    endpoint: string,\n    query: string,\n    variables: RDF.Variable[],\n    context: IActionContext,\n    canContainUndefs: boolean,\n  ): Promise<BindingsStream> {\n    this.lastSourceContext = this.context.merge(context);\n    const rawStream = await this.endpointFetcher.fetchBindings(endpoint, query);\n    this.lastSourceContext = undefined;\n\n    const it = wrap<any>(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY })\n      .map<RDF.Bindings>((rawData: Record<string, RDF.Term>) => this.bindingsFactory.bindings(variables\n        .map((variable) => {\n          const value = rawData[`?${variable.value}`];\n          if (!canContainUndefs && !value) {\n            Actor.getContextLogger(this.context)?.warn(`The endpoint ${endpoint} failed to provide a binding for ${variable.value}.`);\n          }\n          return <[RDF.Variable, RDF.Term]> [ variable, value ];\n        })\n        .filter(([ _, v ]) => Boolean(v))));\n    return it;\n  }\n\n  public toString(): string {\n    return `QuerySourceSparql(${this.url})`;\n  }\n}\n"]}