"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QuerySourceSparql = void 0;
const context_entries_1 = require("@comunica/context-entries");
const core_1 = require("@comunica/core");
const metadata_1 = require("@comunica/metadata");
const asynciterator_1 = require("asynciterator");
const fetch_sparql_endpoint_1 = require("fetch-sparql-endpoint");
const lru_cache_1 = require("lru-cache");
const rdf_data_factory_1 = require("rdf-data-factory");
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const AF = new sparqlalgebrajs_1.Factory();
const DF = new rdf_data_factory_1.DataFactory();
const VAR_COUNT = DF.variable('count');
const COUNT_INFINITY = { type: 'estimate', value: Number.POSITIVE_INFINITY };
class QuerySourceSparql {
    constructor(url, context, mediatorHttp, bindMethod, bindingsFactory, forceHttpGet, cacheSize, countTimeout) {
        this.referenceValue = url;
        this.url = url;
        this.context = context;
        this.mediatorHttp = mediatorHttp;
        this.bindMethod = bindMethod;
        this.bindingsFactory = bindingsFactory;
        this.endpointFetcher = new fetch_sparql_endpoint_1.SparqlEndpointFetcher({
            method: forceHttpGet ? 'GET' : 'POST',
            fetch: (input, init) => this.mediatorHttp.mediate({ input, init, context: this.lastSourceContext }),
            prefixVariableQuestionMark: true,
        });
        this.cache = cacheSize > 0 ?
            new lru_cache_1.LRUCache({ max: cacheSize }) :
            undefined;
        this.countTimeout = countTimeout;
    }
    async getSelectorShape() {
        return QuerySourceSparql.SELECTOR_SHAPE;
    }
    queryBindings(operationIn, context, options) {
        // If bindings are passed, modify the operations
        let operationPromise;
        if (options?.joinBindings) {
            operationPromise = QuerySourceSparql.addBindingsToOperation(this.bindMethod, operationIn, options.joinBindings);
        }
        else {
            operationPromise = Promise.resolve(operationIn);
        }
        const bindings = new asynciterator_1.TransformIterator(async () => {
            // Prepare queries
            const operation = await operationPromise;
            const variables = sparqlalgebrajs_1.Util.inScopeVariables(operation);
            const queryString = context.get(context_entries_1.KeysInitQuery.queryString);
            const selectQuery = !options?.joinBindings && queryString ?
                queryString :
                QuerySourceSparql.operationToSelectQuery(operation, variables);
            const canContainUndefs = QuerySourceSparql.operationCanContainUndefs(operation);
            return this.queryBindingsRemote(this.url, selectQuery, variables, context, canContainUndefs);
        }, { autoStart: false });
        this.attachMetadata(bindings, context, operationPromise);
        return bindings;
    }
    queryQuads(operation, context) {
        this.lastSourceContext = this.context.merge(context);
        const rawStream = this.endpointFetcher.fetchTriples(this.url, context.get(context_entries_1.KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation));
        this.lastSourceContext = undefined;
        const quads = (0, asynciterator_1.wrap)(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY });
        this.attachMetadata(quads, context, Promise.resolve(operation.input));
        return quads;
    }
    queryBoolean(operation, context) {
        this.lastSourceContext = this.context.merge(context);
        const promise = this.endpointFetcher.fetchAsk(this.url, context.get(context_entries_1.KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation));
        this.lastSourceContext = undefined;
        return promise;
    }
    queryVoid(operation, context) {
        this.lastSourceContext = this.context.merge(context);
        const promise = this.endpointFetcher.fetchUpdate(this.url, context.get(context_entries_1.KeysInitQuery.queryString) ?? QuerySourceSparql.operationToQuery(operation));
        this.lastSourceContext = undefined;
        return promise;
    }
    attachMetadata(target, context, operationPromise) {
        // Emit metadata containing the estimated count
        let variablesCount = [];
        let canContainUndefs = false;
        // eslint-disable-next-line no-async-promise-executor,ts/no-misused-promises
        new Promise(async (resolve, reject) => {
            // Prepare queries
            let countQuery;
            try {
                const operation = await operationPromise;
                variablesCount = sparqlalgebrajs_1.Util.inScopeVariables(operation);
                countQuery = QuerySourceSparql.operationToCountQuery(operation);
                canContainUndefs = QuerySourceSparql.operationCanContainUndefs(operation);
                const cachedCardinality = this.cache?.get(countQuery);
                if (cachedCardinality !== undefined) {
                    return resolve(cachedCardinality);
                }
                const timeoutHandler = setTimeout(() => resolve(COUNT_INFINITY), this.countTimeout);
                const bindingsStream = await this
                    .queryBindingsRemote(this.url, countQuery, [VAR_COUNT], context, false);
                bindingsStream.on('data', (bindings) => {
                    clearTimeout(timeoutHandler);
                    const count = bindings.get(VAR_COUNT);
                    const cardinality = { type: 'estimate', value: Number.POSITIVE_INFINITY };
                    if (count) {
                        const cardinalityValue = Number.parseInt(count.value, 10);
                        if (!Number.isNaN(cardinalityValue)) {
                            cardinality.type = 'exact';
                            cardinality.value = cardinalityValue;
                            this.cache?.set(countQuery, cardinality);
                        }
                    }
                    return resolve(cardinality);
                });
                bindingsStream.on('error', () => {
                    clearTimeout(timeoutHandler);
                    resolve(COUNT_INFINITY);
                });
                bindingsStream.on('end', () => {
                    clearTimeout(timeoutHandler);
                    resolve(COUNT_INFINITY);
                });
            }
            catch (error) {
                return reject(error);
            }
        })
            .then((cardinality) => {
            target.setProperty('metadata', {
                state: new metadata_1.MetadataValidationState(),
                cardinality,
                canContainUndefs,
                variables: variablesCount,
            });
        })
            .catch(() => target.setProperty('metadata', {
            state: new metadata_1.MetadataValidationState(),
            cardinality: COUNT_INFINITY,
            canContainUndefs,
            variables: variablesCount,
        }));
    }
    /**
     * Create an operation that includes the bindings from the given bindings stream.
     * @param bindMethod A method for adding bindings to an operation.
     * @param operation The operation to bind to.
     * @param addBindings The bindings to add.
     * @param addBindings.bindings The bindings stream.
     * @param addBindings.metadata The bindings metadata.
     */
    static async addBindingsToOperation(bindMethod, operation, addBindings) {
        const bindings = await addBindings.bindings.toArray();
        switch (bindMethod) {
            case 'values':
                return AF.createJoin([
                    AF.createValues(addBindings.metadata.variables, bindings.map(binding => Object.fromEntries([...binding]
                        .map(([key, value]) => [`?${key.value}`, value])))),
                    operation,
                ], false);
            case 'union': {
                throw new Error('Not implemented yet: "union" case');
            }
            case 'filter': {
                throw new Error('Not implemented yet: "filter" case');
            }
        }
    }
    /**
     * Convert an operation to a select query for this pattern.
     * @param {Algebra.Operation} operation A query operation.
     * @param {RDF.Variable[]} variables The variables in scope for the operation.
     * @return {string} A select query string.
     */
    static operationToSelectQuery(operation, variables) {
        return QuerySourceSparql.operationToQuery(AF.createProject(operation, variables));
    }
    /**
     * Convert an operation to a count query for the number of matching triples for this pattern.
     * @param {Algebra.Operation} operation A query operation.
     * @return {string} A count query string.
     */
    static operationToCountQuery(operation) {
        return QuerySourceSparql.operationToQuery(AF.createProject(AF.createExtend(AF.createGroup(operation, [], [AF.createBoundAggregate(DF.variable('var0'), 'count', AF.createWildcardExpression(), false)]), DF.variable('count'), AF.createTermExpression(DF.variable('var0'))), [DF.variable('count')]));
    }
    /**
     * Convert an operation to a query for this pattern.
     * @param {Algebra.Operation} operation A query operation.
     * @return {string} A query string.
     */
    static operationToQuery(operation) {
        return (0, sparqlalgebrajs_1.toSparql)(operation, { sparqlStar: true });
    }
    /**
     * Check if the given operation may produce undefined values.
     * @param operation
     */
    static operationCanContainUndefs(operation) {
        let canContainUndefs = false;
        sparqlalgebrajs_1.Util.recurseOperation(operation, {
            leftjoin() {
                canContainUndefs = true;
                return false;
            },
            values(values) {
                canContainUndefs = values.bindings.some(bindings => values.variables.some(variable => !(`?${variable.value}` in bindings)));
                return false;
            },
            union(union) {
                // Determine variables in scope of the union branches
                const scopedVariables = union.input
                    .map(sparqlalgebrajs_1.Util.inScopeVariables)
                    .map(variables => variables.map(v => v.value))
                    .map(variables => variables.sort((a, b) => a.localeCompare(b)))
                    .map(variables => variables.join(','));
                // If not all scoped variables in union branches are equal, then we definitely can have undefs
                if (!scopedVariables.every(val => val === scopedVariables[0])) {
                    canContainUndefs = true;
                    return false;
                }
                return true;
            },
        });
        return canContainUndefs;
    }
    /**
     * Send a SPARQL query to a SPARQL endpoint and retrieve its bindings as a stream.
     * @param {string} endpoint A SPARQL endpoint URL.
     * @param {string} query A SPARQL query string.
     * @param {RDF.Variable[]} variables The expected variables.
     * @param {IActionContext} context The source context.
     * @param canContainUndefs If the operation may contain undefined variables.
     * @return {BindingsStream} A stream of bindings.
     */
    async queryBindingsRemote(endpoint, query, variables, context, canContainUndefs) {
        this.lastSourceContext = this.context.merge(context);
        const rawStream = await this.endpointFetcher.fetchBindings(endpoint, query);
        this.lastSourceContext = undefined;
        const it = (0, asynciterator_1.wrap)(rawStream, { autoStart: false, maxBufferSize: Number.POSITIVE_INFINITY })
            .map((rawData) => this.bindingsFactory.bindings(variables
            .map((variable) => {
            const value = rawData[`?${variable.value}`];
            if (!canContainUndefs && !value) {
                core_1.Actor.getContextLogger(this.context)?.warn(`The endpoint ${endpoint} failed to provide a binding for ${variable.value}.`);
            }
            return [variable, value];
        })
            .filter(([_, v]) => Boolean(v))));
        return it;
    }
    toString() {
        return `QuerySourceSparql(${this.url})`;
    }
}
exports.QuerySourceSparql = QuerySourceSparql;
QuerySourceSparql.SELECTOR_SHAPE = {
    type: 'disjunction',
    children: [
        {
            type: 'operation',
            operation: { operationType: 'type', type: sparqlalgebrajs_1.Algebra.types.PROJECT },
            joinBindings: true,
        },
        {
            type: 'operation',
            operation: { operationType: 'type', type: sparqlalgebrajs_1.Algebra.types.CONSTRUCT },
        },
        {
            type: 'operation',
            operation: { operationType: 'type', type: sparqlalgebrajs_1.Algebra.types.DESCRIBE },
        },
        {
            type: 'operation',
            operation: { operationType: 'type', type: sparqlalgebrajs_1.Algebra.types.ASK },
        },
        {
            type: 'operation',
            operation: { operationType: 'type', type: sparqlalgebrajs_1.Algebra.types.COMPOSITE_UPDATE },
        },
    ],
};
//# sourceMappingURL=QuerySourceSparql.js.map