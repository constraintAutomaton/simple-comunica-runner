{"version":3,"file":"instrumentIterator.js","sourceRoot":"","sources":["instrumentIterator.ts"],"names":[],"mappings":";;;AAiBA;;;GAGG;AACH,SAAgB,kBAAkB,CAAC,QAA4B;IAC7D,MAAM,QAAQ,GAAqB;QACjC,KAAK,EAAE,CAAC;QACR,QAAQ,EAAE,CAAC;QACX,QAAQ,EAAE,CAAC;KACZ,CAAC;IACF,uBAAuB,CAAC,QAAQ,EAAE,QAAQ,EAAE,IAAI,CAAC,CAAC;IAClD,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;QAC7B,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;YACtB,OAAO,CAAC,QAAQ,CAAC,CAAC;QACpB,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AAZD,gDAYC;AAED,SAAS,uBAAuB,CAC9B,QAA4B,EAC5B,OAA8D,EAC9D,GAAY;IAEZ,IAAI,CAAC,CAAC,sBAAsB,IAAI,QAAQ,CAAC,EAAE,CAAC;QAC1C,+BAA+B;QACzB,QAAS,CAAC,oBAAoB,GAAG,IAAI,CAAC;QAE5C,cAAc;QACd,IAAI,OAAO,IAAI,QAAQ,EAAE,CAAC;YACxB,MAAM,OAAO,GAAQ,QAAQ,CAAC,KAAK,CAAC;YACpC,QAAQ,CAAC,KAAK,GAAG,CAAC,KAAa,EAAE,IAAgB,EAAE,EAAE;gBACnD,MAAM,SAAS,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;gBACpC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,GAAG,EAAE;oBACjC,OAAO,CAAC,QAAQ,IAAI,WAAW,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC;oBAClD,IAAI,EAAE,CAAC;gBACT,CAAC,CAAC,CAAC;YACL,CAAC,CAAC;QACJ,CAAC;QAED,aAAa;QACb,IAAI,MAAM,IAAI,QAAQ,EAAE,CAAC;YACvB,6CAA6C;YAC7C,MAAM,OAAO,GAAQ,QAAQ,CAAC,IAAI,CAAC;YACnC,QAAQ,CAAC,IAAI,GAAG,GAAG,EAAE;gBACnB,MAAM,SAAS,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;gBACpC,MAAM,GAAG,GAAG,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACnC,IAAI,GAAG,IAAI,GAAG,EAAE,CAAC;oBACf,OAAO,CAAC,KAAK,EAAE,CAAC;gBAClB,CAAC;gBACD,OAAO,CAAC,QAAQ,IAAI,WAAW,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC;gBAClD,OAAO,GAAG,CAAC;YACb,CAAC,CAAC;QACJ,CAAC;QAED,qBAAqB;QACrB,IAAI,GAAG,EAAE,CAAC;YACR,MAAM,SAAS,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;YACpC,QAAQ,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;gBACtB,OAAO,CAAC,QAAQ,GAAG,WAAW,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC;YACnD,CAAC,CAAC,CAAC;QACL,CAAC;QAED,sBAAsB;QACtB,IAAI,SAAS,IAAI,QAAQ,EAAE,CAAC;YAC1B,uBAAuB,CAAM,QAAQ,CAAC,OAAO,EAAE,OAAO,EAAE,KAAK,CAAC,CAAC;QACjE,CAAC;IACH,CAAC;AACH,CAAC","sourcesContent":["import type { AsyncIterator } from 'asynciterator';\n\nexport type IteratorCounters = {\n  /**\n   * The total time spent within `_read` and `read`.\n   */\n  timeSelf: number;\n  /**\n   * The time between creation and ending.\n   */\n  timeLife: number;\n  /**\n   * The number of elements produced.\n   */\n  count: number;\n};\n\n/**\n * Profile an iterator by monkey-patching its `_read` and `read` methods.\n * @param iterator\n */\nexport function instrumentIterator(iterator: AsyncIterator<any>): Promise<IteratorCounters> {\n  const counters: IteratorCounters = {\n    count: 0,\n    timeSelf: 0,\n    timeLife: 0,\n  };\n  instrumentIteratorInner(iterator, counters, true);\n  return new Promise((resolve) => {\n    iterator.on('end', () => {\n      resolve(counters);\n    });\n  });\n}\n\nfunction instrumentIteratorInner(\n  iterator: AsyncIterator<any>,\n  counter: { timeSelf: number; timeLife: number; count: number },\n  top: boolean,\n): void {\n  if (!('_profileInstrumented' in iterator)) {\n    // Only patch an iterator once.\n    (<any>iterator)._profileInstrumented = true;\n\n    // Patch _read\n    if ('_read' in iterator) {\n      const readOld: any = iterator._read;\n      iterator._read = (count: number, done: () => void) => {\n        const startTime = performance.now();\n        readOld.call(iterator, count, () => {\n          counter.timeSelf += performance.now() - startTime;\n          done();\n        });\n      };\n    }\n\n    // Patch read\n    if ('read' in iterator) {\n      // eslint-disable-next-line ts/unbound-method\n      const readOld: any = iterator.read;\n      iterator.read = () => {\n        const startTime = performance.now();\n        const ret = readOld.call(iterator);\n        if (top && ret) {\n          counter.count++;\n        }\n        counter.timeSelf += performance.now() - startTime;\n        return ret;\n      };\n    }\n\n    // Measure total time\n    if (top) {\n      const startTime = performance.now();\n      iterator.on('end', () => {\n        counter.timeLife = performance.now() - startTime;\n      });\n    }\n\n    // Also patch children\n    if ('_source' in iterator) {\n      instrumentIteratorInner(<any>iterator._source, counter, false);\n    }\n  }\n}\n"]}