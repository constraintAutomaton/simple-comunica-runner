import { type IQuery } from './query';
import { IShape } from './Shape';
/**
 * Determine if a query is contained inside a shape.
 * It provide detail information about the containment and weither or not
 * the documents linked with the shape should be followed.
 * @param param {IContainementArg} - the shape and the query to evaluate
 * @returns {IResult} result relative to the containement of the query inside of the shape
 */
export declare function solveShapeQueryContainment({ query, shapes }: IContainementArg): IResult;
export type StarPatternName = string;
/**
 * The argument of the report alignment function
 */
export interface IContainementArg {
    query: IQuery;
    shapes: IShape[];
    dependentShapes?: IShape[];
}
export type ShapeName = string;
/**
 * The result of the alignment
 */
export interface IResult {
    conditionalLink: IConditionalLink[];
    visitShapeBoundedResource: Map<ShapeName, boolean>;
    starPatternsContainment: Map<StarPatternName, IContainmentResult>;
}
/**
 * The result of a containement
 */
export type IContainmentResult = Readonly<{
    result: ContainmentResult;
    /**
     * The shape iri associated with the containement
     * Will be undefined if the the star pattern has no alignment with any shape
     */
    target?: string[];
    /**
     * If the result is an alignment then we record the shape
     * that have a binding with RDF class
     */
    bindingByRdfClass?: string[];
}>;
/**
 * The result of a containement
 */
export declare enum ContainmentResult {
    CONTAIN = 0,
    ALIGNED = 1,
    DEPEND = 2,
    REJECTED = 3
}
/**
 * A conditional link
 */
export interface IConditionalLink {
    link: string;
    starPatternName: string;
}
