{"version":3,"file":"containment.js","sourceRoot":"","sources":["../../lib/containment.ts"],"names":[],"mappings":"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","sourcesContent":["import { Bindings, IBindings, IDependentStarPattern } from './Binding'\nimport { TYPE_DEFINITION } from './constant';\nimport { generateStarPatternUnion, type IQuery } from './query';\nimport { IShape } from './Shape';\nimport type { ITriple } from './Triple';\n\n/**\n * Determine if a query is contained inside a shape.\n * It provide detail information about the containment and weither or not \n * the documents linked with the shape should be followed.\n * @param param {IContainementArg} - the shape and the query to evaluate\n * @returns {IResult} result relative to the containement of the query inside of the shape\n */\nexport function solveShapeQueryContainment({ query, shapes }: IContainementArg): IResult {\n  const bindingResult = new Map<ShapeName, Map<StarPatternName, IBindingStatus>>();\n  const starPatternsContainment = new Map<StarPatternName, IContainmentResult>();\n  const queryStarPattern: QueryStarPattern = new Map();\n\n  const groupedShapes = groupShapeBydependencies(shapes);\n\n  for (const [starPatternsName, starPatternWithDependencies] of query.starPatterns) {\n    for (const { triple } of starPatternWithDependencies.starPattern.values()) {\n      queryStarPattern.set(triple.toString(), triple);\n    }\n    starPatternsContainment.set(starPatternsName, { result: ContainmentResult.REJECTED });\n  }\n\n  // dependent, origin \n  const nestedContainedStarPatterns = new Map<string, Map<string, IDependentStarPattern>>();\n\n  for (const { shape, dependencies } of groupedShapes) {\n    bindingResult.set(shape.name, new Map());\n    const bindingResultofShape = bindingResult.get(shape.name)!;\n    for (const [starPatternName, starPattern] of query.starPatterns) {\n      const starPatternUnion = generateStarPatternUnion(query.union ?? [], starPatternName);\n      const bindings = new Bindings(shape, starPattern, dependencies, starPatternUnion);\n      const currentNestedStarPattern = bindings.getNestedContainedStarPatternName();\n      for (const starPattern of currentNestedStarPattern) {\n        const currentNestedContainedStarPatterns = nestedContainedStarPatterns.get(starPattern.starPattern);\n        if (currentNestedContainedStarPatterns === undefined) {\n          nestedContainedStarPatterns.set(starPattern.starPattern, new Map([[starPatternName, starPattern]]));\n        } else {\n          currentNestedContainedStarPatterns.set(starPatternName, starPattern);\n        }\n      }\n      bindingResultofShape.set(starPatternName, { result: bindings, shape });\n      for (const triple of bindings.getBoundTriple()) {\n        queryStarPattern.set(triple.toString(), undefined);\n      }\n    }\n  }\n\n  for (const [shapeName, starPatternBinding] of bindingResult) {\n    const currentShapeBindingResult = bindingResult.get(shapeName)!;\n    for (const [starPatternName, bindingResult] of starPatternBinding) {\n      const originOfDependency = nestedContainedStarPatterns.get(starPatternName);\n      // validate that there are no cycles if there are cycles we analyse the star pattern independently\n      for (const [origin, dependencyInfo] of originOfDependency ?? []) {\n        if (!nestedContainedStarPatterns.has(origin)) {\n          currentShapeBindingResult.set(starPatternName, { ...bindingResult, dependent: dependencyInfo });\n          break;\n        }\n      }\n    }\n  }\n\n  for (const starPatternBinding of bindingResult.values()) {\n    for (const [starPatternName, result] of starPatternBinding) {\n      if (result.dependent === undefined) {\n        updateStarPatternContainment(starPatternsContainment, result.result, starPatternName, result.shape);\n      } else {\n        // check the shape contained related to the dependent star pattern\n        const dependendShapes = [];\n        for (const [shapeName, nestedBinding] of bindingResult) {\n          const nestedResult = nestedBinding.get(starPatternName);\n          if (nestedResult !== undefined) {\n            if (nestedResult.result.isFullyBounded()) {\n              dependendShapes.push(shapeName);\n            }\n          }\n        }\n\n        const constraintTarget = [];\n        for(const [shapeName, nestedBinding] of bindingResult){\n          const originBinding = nestedBinding.get(result.dependent.origin);\n          if(originBinding!==undefined){\n            constraintTarget.push(shapeName);\n          }\n        }\n        // we check if there is less shapes contained than the constraint of the dependency\n        const target = constraintTarget.length > dependendShapes.length\n          || constraintTarget.length === 0\n          ? dependendShapes : result.dependent.shape;\n\n        starPatternsContainment.set(starPatternName, { result: ContainmentResult.DEPEND, target });\n      }\n    }\n  }\n\n\n  const conditionalLink: IConditionalLink[] = [];\n  for (const triple of queryStarPattern.values()) {\n    if (triple !== undefined) {\n      if (!Array.isArray(triple.object) && triple.object?.termType === \"NamedNode\") {\n        conditionalLink.push({\n          link: triple.object.value,\n          starPatternName: triple.subject\n        });\n      }\n    }\n  }\n\n  return {\n    conditionalLink: shapes.length === 0 ? [] : conditionalLink,\n    starPatternsContainment,\n    visitShapeBoundedResource: generateVisitStatus(bindingResult, shapes)\n  };\n\n}\n\nfunction updateStarPatternContainment(starPatternsContainment: Map<ShapeName, IContainmentResult>, bindings: IBindings, starPatternName: StarPatternName, shape: IShape): void {\n  const prevContainmentResult = starPatternsContainment.get(starPatternName)!;\n\n  if (bindings.shouldVisitShape() && bindings.getUnboundedTriple().length > 0 && prevContainmentResult.result !== ContainmentResult.CONTAIN) {\n    const classBinding = bindings.getBindings().get(TYPE_DEFINITION.value);\n\n    starPatternsContainment.set(starPatternName, {\n      result: ContainmentResult.ALIGNED,\n      target: (prevContainmentResult.target ?? []).concat(shape.name),\n      bindingByRdfClass: (prevContainmentResult.bindingByRdfClass ?? [])\n        .concat(classBinding !== undefined ? shape.name : [])\n    });\n\n  }\n  if (bindings.shouldVisitShape() && bindings.isFullyBounded()) {\n    starPatternsContainment.set(starPatternName, {\n      result: ContainmentResult.CONTAIN,\n      target: prevContainmentResult.result === ContainmentResult.ALIGNED ? [shape.name] :\n        (prevContainmentResult.target ?? []).concat(shape.name)\n    });\n  }\n\n}\n\nfunction groupShapeBydependencies(shapes: IShape[], dependentShapes?: IShape[]): IShapeWithDependencies[] {\n  const resp: IShapeWithDependencies[] = [];\n  for (let i = 0; i < shapes.length; i++) {\n    const target = shapes[i];\n    const others = new Map(\n      shapes.slice(0, i).concat(shapes.slice(i + 1)).concat(dependentShapes ?? []).map((shape) => [shape.name, shape]));\n    resp.push({\n      shape: target,\n      dependencies: others\n    });\n  }\n  return resp\n}\n\n\nfunction generateVisitStatus(bindings: Map<ShapeName, Map<StarPatternName, IBindingStatus>>, shapes: IShape[]): Map<ShapeName, boolean> {\n  const visitShapeBoundedResource = new Map<ShapeName, boolean>();\n  for (const shape of shapes) {\n    visitShapeBoundedResource.set(shape.name, false);\n  }\n\n  for (const [shapeName, starPatternBindings] of bindings) {\n    for (const bindingShape of starPatternBindings.values()) {\n      if (bindingShape !== undefined) {\n        const previousStatus = visitShapeBoundedResource.get(shapeName)!;\n        const currentStatus = bindingShape.result.shouldVisitShape();\n\n        if (previousStatus === false && currentStatus === true) {\n          visitShapeBoundedResource.set(shapeName, true);\n        }\n      }\n    }\n  }\n\n  return visitShapeBoundedResource;\n}\n\ninterface IBindingStatus {\n  result: IBindings;\n  shape: IShape;\n  dependent?: IDependentStarPattern;\n}\n\ninterface IShapeWithDependencies {\n  shape: IShape;\n  dependencies: Map<string, IShape>;\n}\n\nexport type StarPatternName = string;\ntype QueryStarPattern = Map<string, ITriple | undefined>;\n\n/**\n * The argument of the report alignment function\n */\nexport interface IContainementArg {\n  query: IQuery;\n  shapes: IShape[];\n  // additional shapes to not be calculated\n  dependentShapes?: IShape[];\n}\n\n\nexport type ShapeName = string;\n\n/**\n * The result of the alignment\n */\nexport interface IResult {\n  // URL from the object of triples that are not bound by a shape\n  conditionalLink: IConditionalLink[];\n  // The documents associated with a shape that can be followed\n  visitShapeBoundedResource: Map<ShapeName, boolean>;\n  // The type of containment of each star patterns with there associated shapes\n  starPatternsContainment: Map<StarPatternName, IContainmentResult>;\n}\n\n/**\n * The result of a containement\n */\nexport type IContainmentResult = Readonly<{\n  // The type of containement\n  result: ContainmentResult;\n  /**\n   * The shape iri associated with the containement\n   * Will be undefined if the the star pattern has no alignment with any shape\n   */\n  target?: string[];\n  /**\n   * If the result is an alignment then we record the shape\n   * that have a binding with RDF class\n   */\n  bindingByRdfClass?: string[];\n}>;\n\n/**\n * The result of a containement\n */\nexport enum ContainmentResult {\n  // Is contained\n  CONTAIN,\n  // Has at least one binding\n  ALIGNED,\n  // Is a dependency of a contained star pattern\n  DEPEND,\n  // Has no binding\n  REJECTED,\n}\n\n/**\n * A conditional link\n */\nexport interface IConditionalLink {\n  // The URL of the link\n  link: string,\n  // The star pattern associated with it\n  starPatternName: string\n}\n"]}