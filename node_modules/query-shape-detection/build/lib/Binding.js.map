{"version":3,"file":"Binding.js","sourceRoot":"","sources":["../../lib/Binding.ts"],"names":[],"mappings":"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","sourcesContent":["import { ContraintType, IContraint, IPredicate, IShape, OneOfPathIndexed } from \"./Shape\";\nimport { IStarPatternWithDependencies, type ITriple, Triple } from \"./Triple\";\n\n/**\n * A binding from a query to a shape\n */\nexport interface IBindings {\n    /**\n     * Indicate if a star pattern is contained in a shape\n     * @returns {boolean} indicate if the query is contained in a shape\n     */\n    isFullyBounded: () => boolean;\n    /**\n     * Indicate that the documents linked to the shapes should be visited if there are\n     * complete or partial binding\n     * @returns {boolean} indicate if the documents link to the shapes should be visited\n     */\n    shouldVisitShape: () => boolean;\n    /**\n     * \n     * Return the unbounded triples\n     * @returns {ITriple[]} The binded triples \n     */\n    getUnboundedTriple: () => ITriple[];\n    /**\n     * Return the bindings, the value is undefined if the triple cannot be bind to the shape\n     * @returns {Map<string, ITriple | undefined>} the internal bindings\n     */\n    getBindings: () => Map<string, ITriple | undefined>;\n    /**\n     * Return the bind triple\n     * @returns {ITriple[]} the bind triple\n     */\n    getBoundTriple: () => ITriple[];\n    /**\n     * Return the name of the decendent star pattern if the current star pattern is contained\n     * @returns {[string, string | undefined][]} the star pattern name of the decendent if the current star pattern is contained\n     */\n    getNestedContainedStarPatternName: () => IDependentStarPattern[];\n}\n\nexport interface IDependentStarPattern {\n    starPattern: string;\n    shape?: string[];\n    origin: string\n}\n\nexport enum ConstraintResult {\n    INAPPLICABLE,\n    RESPECT,\n    NOT_RESPECT\n}\n\n/**\n * Calculate the bindings from a shape and a query\n */\nexport class Bindings implements IBindings {\n    // indexed by predicate\n    private bindings = new Map<string, ITriple | undefined>();\n    private unboundTriple: ITriple[] = [];\n    private fullyBounded = false;\n    private readonly closedShape: boolean;\n    private nestedContainedStarPatternName: IDependentStarPattern[] = [];\n    private nestedContainedStarPatternNameShapesContained = new Map<string, string[]>();\n    private readonly oneOfs: OneOfBinding[];\n    private unionBindings: UnionBinding[] = [];\n    private shapePredicateBind = new Map<string, boolean>();\n    private strict: boolean;\n    private allOptional = true;\n\n    public constructor(shape: IShape, starPattern: IStarPatternWithDependencies, linkedShape: Map<string, IShape>, unionStarPattern?: IStarPatternWithDependencies[][], strict?: boolean) {\n        this.strict = strict ?? false;\n        this.closedShape = shape.closed;\n        for (const { triple } of starPattern.starPattern.values()) {\n            this.bindings.set(triple.predicate, undefined);\n            this.allOptional = this.allOptional && triple.isOptional === true;\n        }\n        for (const predicate of shape.getAll()) {\n            this.shapePredicateBind.set(predicate.name, false);\n        }\n        this.oneOfs = shape.oneOfIndexed.map((oneOfs: OneOfPathIndexed[]) => new OneOfBinding(oneOfs));\n        this.calculateBinding(shape, starPattern, linkedShape, unionStarPattern ?? []);\n\n        // delete duplicate\n        this.unboundTriple = Array.from(new Set(this.unboundTriple));\n    }\n\n\n    private calculateBinding(shape: IShape, starPattern: IStarPatternWithDependencies, linkedShape: Map<string, IShape>, unionStarPattern: IStarPatternWithDependencies[][]): void {\n        for (const union of unionStarPattern) {\n            this.unionBindings.push(new UnionBinding(shape, union, linkedShape));\n        }\n        const negatedTriples: ITriple[] = [];\n        for (const { triple, dependencies } of starPattern.starPattern.values()) {\n            if (!this.closedShape) {\n                this.bindings.set(triple.predicate, triple);\n                continue;\n            }\n            if (triple.predicate === Triple.NEGATIVE_PREDICATE_SET) {\n                negatedTriples.push(triple);\n                continue;\n            }\n            const singlePredicate = shape.get(triple.predicate);\n            let predicates: IPredicate[] = [];\n            // check if the triple match a disjunction\n            for (const oneOfBinding of this.oneOfs) {\n                const predicatesOneOf = oneOfBinding.get(triple.predicate);\n                if (predicatesOneOf !== undefined) {\n                    predicates = predicates.concat(predicatesOneOf);\n                }\n            }\n\n            if (singlePredicate === undefined &&\n                predicates.length === 0\n                && triple.isOptional !== true &&\n                !this.strict) {\n                this.unboundTriple.push(triple);\n            } else {\n                if (singlePredicate !== undefined) {\n                    predicates.push(singlePredicate);\n                }\n                this.evaluateConstraint(predicates, triple, linkedShape, shape, dependencies);\n            }\n\n\n\n        }\n        // negative triple in a strict containment mean that the we can take any values\n        // see paper https://link.springer.com/chapter/10.1007/978-3-319-25007-6_1\n        if (!this.strict) {\n            for (const triple of negatedTriples) {\n                let hasBind = false;\n                for (const [predicate, isBind] of this.shapePredicateBind) {\n                    if (!isBind && !triple.negatedSet?.has(predicate)) {\n                        this.bindings.set(triple.predicate, triple);\n                        this.shapePredicateBind.set(predicate, true);\n                        hasBind = true;\n                        continue;\n                    }\n                }\n                if (!hasBind) {\n                    this.unboundTriple.push(triple);\n                }\n            }\n        }\n\n        if (shape.closed === false) {\n            this.fullyBounded = starPattern.starPattern.size !== 0;\n        } else {\n            let boundedUnion = true;\n            for (const unionBinding of this.unionBindings) {\n                boundedUnion = ((unionBinding.hasOneContained && !this.strict) ||\n                    (this.strict && unionBinding.areAllContained)) && boundedUnion;\n            }\n            this.fullyBounded = this.unboundTriple.length === 0 && starPattern.starPattern.size !== 0 && boundedUnion;\n        }\n        if (this.fullyBounded) {\n            const cycle = new Set<string>();\n            const rejectedValues = new Set<string>();\n            const result = new Map<string, string[]>();\n            this.fillNestedContainedStarPatternName(starPattern, cycle, starPattern.name, rejectedValues, result);\n            for (const starPattern of rejectedValues) {\n                result.delete(starPattern);\n            }\n            let nestedContainedStarPatternName: string[] = [];\n            for (const nestedConstrainStarPattern of result.values()) {\n                nestedContainedStarPatternName = nestedContainedStarPatternName.concat(nestedConstrainStarPattern);\n            }\n\n            // delete duplicate\n            nestedContainedStarPatternName = Array.from(new Set(nestedContainedStarPatternName));\n            this.nestedContainedStarPatternName = nestedContainedStarPatternName\n                .map((starPatternName) => {\n                    return {\n                        shape: this.nestedContainedStarPatternNameShapesContained.get(starPatternName),\n                        starPattern: starPatternName,\n                        origin: starPattern.name\n                    };\n                });\n\n            for (const unionBinding of this.unionBindings) {\n                this.nestedContainedStarPatternName = this.nestedContainedStarPatternName.concat(unionBinding.dependentStarPattern);\n            }\n            // delete duplicate\n            this.nestedContainedStarPatternName = Array.from(new Set(this.nestedContainedStarPatternName));\n        }\n    }\n\n    private evaluateConstraint(predicates: IPredicate[],\n        triple: ITriple,\n        linkedShape: Map<string, IShape>,\n        shape: IShape,\n        dependencies: IStarPatternWithDependencies | undefined): void {\n        let validConstraint = false;\n        for (const predicate of predicates) {\n            const constraint = predicate.constraint;\n\n            if (constraint === undefined) {\n                validConstraint = validConstraint || true;\n                break;\n            }\n\n            const shapeContraintResult = this.handleShapeConstraint(constraint, triple, linkedShape, shape, dependencies);\n            if (shapeContraintResult === ConstraintResult.NOT_RESPECT) {\n                validConstraint = validConstraint || false;\n                continue;\n            }\n            if (shapeContraintResult === ConstraintResult.RESPECT) {\n                validConstraint = validConstraint || true;\n                continue;\n            }\n\n            const typeConstraintResult = Bindings.handleShapeType(constraint, triple);\n            if (typeConstraintResult === ConstraintResult.NOT_RESPECT) {\n                validConstraint = validConstraint || false;\n                continue;\n            }\n            if (typeConstraintResult === ConstraintResult.RESPECT) {\n                validConstraint = validConstraint || true;\n                continue;\n            }\n\n            // all the constraint are valid so we can skip the rest of the predicate with the same IRI but\n            // possible different constraints.\n            validConstraint = validConstraint || true;\n            break;\n        }\n\n        if (validConstraint) {\n            this.bindings.set(triple.predicate, triple);\n            this.shapePredicateBind.set(triple.predicate, true);\n        } else if (!this.strict && triple.isOptional === true && this.allOptional === false) {\n            this.bindings.set(triple.predicate, triple);\n        } else {\n            this.unboundTriple.push(triple);\n        }\n    }\n\n    private fillNestedContainedStarPatternName(starPattern: IStarPatternWithDependencies, cycle: Set<string>, originalName: string, rejectedValues: Set<string>, result: Map<string, string[]>): void {\n        for (const { dependencies } of starPattern.starPattern.values()) {\n            if (dependencies !== undefined) {\n                const currentBranch = result.get(starPattern.name);\n                if (currentBranch !== undefined) {\n                    currentBranch.push(dependencies.name);\n                } else {\n                    result.set(starPattern.name, [dependencies.name]);\n                }\n                if (result.has(dependencies.name)) {\n                    cycle.add(dependencies.name);\n                    cycle.add(starPattern.name);\n                }\n                // we don't make dependent star pattern directly cycled connected to the current star pattern\n                if (result.has(dependencies.name) && dependencies.name === originalName) {\n                    rejectedValues.add(dependencies.name);\n                    rejectedValues.add(starPattern.name);\n                }\n                // to avoid infinite loop\n                if (!cycle.has(dependencies.name)) {\n                    this.fillNestedContainedStarPatternName(dependencies, cycle, originalName, rejectedValues, result);\n                }\n            }\n        }\n\n    }\n\n    private handleShapeConstraint(\n        constraint: IContraint,\n        triple: ITriple,\n        linkedShape: Map<string, IShape>,\n        currentShape: IShape,\n        dependencies?: IStarPatternWithDependencies): ConstraintResult {\n        if (constraint.type === ContraintType.SHAPE && dependencies !== undefined && constraint.value.size == 1) {\n            const shapeName: string = constraint.value.values().next().value;\n            const currentLinkedShape = currentShape.name === shapeName ? currentShape : linkedShape.get(shapeName);\n            if (currentLinkedShape === undefined) {\n                return ConstraintResult.RESPECT;\n            }\n\n            const nestedBinding = new Bindings(currentLinkedShape, dependencies, linkedShape, [], this.strict);\n            if (nestedBinding.isFullyBounded()) {\n                this.bindings.set(triple.predicate, triple);\n                this.nestedContainedStarPatternNameShapesContained = new Map(\n                    [\n                        ...this.nestedContainedStarPatternNameShapesContained,\n                        ...nestedBinding.nestedContainedStarPatternNameShapesContained\n                    ]);\n                const dependentShape = this.nestedContainedStarPatternNameShapesContained.get(dependencies.name);\n                if (dependentShape === undefined) {\n                    this.nestedContainedStarPatternNameShapesContained.set(dependencies.name, [currentLinkedShape.name]);\n                } else {\n                    dependentShape.push(currentLinkedShape.name);\n                }\n                return ConstraintResult.RESPECT;\n            } else {\n                return ConstraintResult.NOT_RESPECT;\n            }\n        }\n\n        return ConstraintResult.INAPPLICABLE;\n    }\n\n    private static handleShapeType(\n        constraint: IContraint,\n        triple: ITriple): ConstraintResult {\n        if (constraint.type === ContraintType.TYPE &&\n            !Array.isArray(triple.object) &&\n            triple.object.termType === \"Literal\"\n            && constraint.value.has(triple.object.datatype.value)\n        ) {\n            return ConstraintResult.RESPECT;\n        } else if (constraint.type === ContraintType.TYPE &&\n            !Array.isArray(triple.object) &&\n            triple.object.termType === \"NamedNode\"\n            && constraint.value.has(triple.object.value)) {\n            return ConstraintResult.RESPECT;\n\n        } else if (constraint.type === ContraintType.TYPE &&\n            !Array.isArray(triple.object) &&\n            triple.object.termType === \"Literal\"\n            && !constraint.value.has(triple.object.datatype.value)) {\n            return ConstraintResult.NOT_RESPECT;\n        }\n        else if (constraint.type === ContraintType.TYPE &&\n            !Array.isArray(triple.object) &&\n            triple.object.termType === \"NamedNode\"\n            && !constraint.value.has(triple.object.value)) {\n            return ConstraintResult.NOT_RESPECT;\n        } else if (constraint.type === ContraintType.TYPE &&\n            Array.isArray(triple.object)) {\n            for (const object of triple.object) {\n                if (constraint.value.has(object.value) || (object.termType === \"Literal\" && constraint.value.has(object.datatype.value))) {\n                    return ConstraintResult.RESPECT;\n                }\n            }\n        }\n\n        return ConstraintResult.INAPPLICABLE;\n    }\n\n    public isFullyBounded(): boolean {\n        return this.fullyBounded;\n    }\n\n    public getUnboundedTriple(): ITriple[] {\n        return new Array(...this.unboundTriple);\n    }\n\n    public getBindings(): Map<string, ITriple | undefined> {\n        return new Map(this.bindings);\n    }\n\n    public getBoundTriple(): ITriple[] {\n        const resp: ITriple[] = [];\n        for (const triple of this.bindings.values()) {\n            if (triple !== undefined) {\n                resp.push(triple);\n            }\n        }\n        return resp;\n    }\n\n    public shouldVisitShape(): boolean {\n        return this.getBoundTriple().length > 0;\n    }\n\n    public getNestedContainedStarPatternName(): IDependentStarPattern[] {\n        return this.nestedContainedStarPatternName;\n    }\n}\n\nexport class OneOfBinding {\n    private readonly paths: OneOfPathIndexed[];\n\n    public constructor(paths: OneOfPathIndexed[]) {\n        this.paths = paths;\n    }\n\n    public get(el: string): IPredicate[] | undefined {\n        const resp = [];\n        for (const path of this.paths) {\n            const predicate = path.get(el);\n            if (predicate !== undefined) {\n                resp.push(predicate);\n            }\n        }\n        return resp.length === 0 ? undefined : resp;\n    }\n}\n\nexport class UnionBinding {\n    private readonly bindings: IBindings[];\n    public readonly hasOneContained: boolean;\n    public readonly areAllContained: boolean;\n    public readonly dependentStarPattern: IDependentStarPattern[];\n\n    public constructor(shape: IShape, union: IStarPatternWithDependencies[], linkedShape: Map<string, IShape>) {\n        this.bindings = [];\n        for (const starPattern of union) {\n            this.bindings.push(new Bindings(shape, starPattern, linkedShape));\n        }\n        this.hasOneContained = this.determineHasOneAtLeastContainment();\n        this.areAllContained = this.determineAllContained();\n\n        const dependentStarPatternSet = new Map<string, IDependentStarPattern>();\n\n        for (const binding of this.bindings) {\n            for (const startPattern of binding.getNestedContainedStarPatternName()) {\n                dependentStarPatternSet.set(startPattern.starPattern, startPattern);\n            }\n        }\n\n        this.dependentStarPattern = Array.from(dependentStarPatternSet.values());\n    }\n\n    private determineHasOneAtLeastContainment(): boolean {\n        let hasOneContainment = false;\n        for (const binding of this.bindings) {\n            hasOneContainment = hasOneContainment || binding.isFullyBounded();\n        }\n        return hasOneContainment;\n    }\n\n    private determineAllContained(): boolean {\n        let hasOneContainment = true;\n        for (const binding of this.bindings) {\n            hasOneContainment = hasOneContainment && binding.isFullyBounded();\n        }\n        return hasOneContainment;\n    }\n}"]}