"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Triple = exports.AlignmentType = void 0;
/**
 * The type of alignment
 */
var AlignmentType;
(function (AlignmentType) {
    AlignmentType[AlignmentType["WEAK"] = 0] = "WEAK";
    AlignmentType[AlignmentType["STRONG"] = 1] = "STRONG";
    AlignmentType[AlignmentType["None"] = 2] = "None";
})(AlignmentType || (exports.AlignmentType = AlignmentType = {}));
/**
 * A Triple
 */
class Triple {
    /**
   * Indicate that the predicate can be anything.
   * It is used for the "NegatedPropertySet"
   * https://www.w3.org/TR/sparql11-query/#propertypaths
   *
   * The negatedSet property must be checked for any analysis
   */
    static NEGATIVE_PREDICATE_SET = "*";
    predicate;
    subject;
    object;
    // the cardinality of the predicate
    cardinality;
    negatedSet;
    isOptional;
    /**
     *
     * @param {ITripleArgs} tripleObject - A triple object
     */
    constructor({ subject, predicate, object, cardinality, negatedSet: negative, isOptional }) {
        this.predicate = predicate;
        this.object = object;
        this.subject = subject;
        this.cardinality = cardinality;
        this.negatedSet = negative;
        this.isOptional = isOptional ?? false;
        if (this.cardinality !== undefined && this.cardinality.min === 0) {
            this.isOptional = true;
        }
        Object.freeze(this.negatedSet);
        Object.freeze(this.cardinality);
        Object.freeze(this.predicate);
        Object.freeze(this.isOptional);
        Object.freeze(this.object);
        Object.freeze(this.subject);
        Object.freeze(this);
    }
    /**
     * Return a triple object
     * @returns {ITripleArgs} a Triple object
     */
    toObject() {
        return {
            subject: this.subject,
            predicate: this.predicate,
            object: this.object,
            cardinality: this.cardinality,
            isOptional: this.isOptional
        };
    }
    getLinkedStarPattern() {
        if (!Array.isArray(this.object) && (this.object?.termType === "Variable" || this.object?.termType === "NamedNode")) {
            return this.object.value;
        }
    }
    toString() {
        return !this.negatedSet
            ?
                `<${this.subject}> <${this.predicate}> <${JSON.stringify(this.object)}>`
            :
                `<${this.subject}> NEGATE(<${Array.from(this.negatedSet).join(' ')}>) <${JSON.stringify(this.object)}>`;
    }
}
exports.Triple = Triple;
//# sourceMappingURL=Triple.js.map