"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateStarPatternUnion = generateStarPatternUnion;
exports.generateQuery = generateQuery;
const sparqlalgebrajs_1 = require("sparqlalgebrajs");
const Triple_1 = require("./Triple");
const constant_1 = require("./constant");
function generateStarPatternUnion(union, starPatternName) {
    const resp = [];
    for (const unionSet of union) {
        const currentUnionSet = [];
        for (const union of unionSet) {
            const requestedStarPattern = union.starPatterns.get(starPatternName);
            if (requestedStarPattern !== undefined) {
                currentUnionSet.push(requestedStarPattern);
            }
        }
        if (currentUnionSet.length > 0) {
            resp.push(currentUnionSet);
        }
    }
    return resp;
}
/**
 * Divide a query into star patterns
 * @param {Algebra.Operation} algebraQuery - the algebra of a query
 * @returns {Query} - A query divided into subject group where the predicate has to be an IRI
 * @todo add support for the bind operator
 */
function generateQuery(algebraQuery, optional) {
    const accumulatedTriples = new Map();
    // the binding value to the value
    const accumatedValues = new Map();
    const accumulatedUnion = [];
    QueryHandler.collectFromAlgebra(algebraQuery, accumulatedTriples, accumatedValues, accumulatedUnion, optional);
    return buildQuery(accumulatedTriples, accumatedValues, accumulatedUnion);
}
function buildQuery(tripleArgs, values, accumulatedUnion) {
    const innerQuery = new Map();
    const resp = { starPatterns: innerQuery, filterExpression: "" };
    if (accumulatedUnion.length > 0) {
        resp.union = accumulatedUnion;
    }
    // generate the root star patterns
    for (const [starPatternSubject, { triples, isVariable }] of tripleArgs) {
        for (let triple of triples.values()) {
            if (!Array.isArray(triple.object) && triple.object?.termType === "Variable") {
                const value = values.get(triple.object.value);
                if (value !== undefined) {
                    triple = new Triple_1.Triple({
                        subject: triple.subject,
                        predicate: triple.predicate,
                        object: value,
                        cardinality: triple.cardinality,
                        negatedSet: triple.negatedSet
                    });
                }
            }
            const starPattern = innerQuery.get(starPatternSubject);
            if (starPattern === undefined) {
                const predicateWithDependencies = { triple: triple, dependencies: undefined };
                innerQuery.set(starPatternSubject, {
                    starPattern: new Map([
                        [triple.predicate, predicateWithDependencies]
                    ]),
                    name: starPatternSubject,
                    isVariable: isVariable,
                });
            }
            else {
                const predicateWithDependencies = { triple: triple, dependencies: undefined };
                starPattern.starPattern.set(triple.predicate, predicateWithDependencies);
            }
        }
    }
    // set the dependencies of the star pattern
    for (const starPatternWithDependencies of innerQuery.values()) {
        for (const tripleWithDependencies of starPatternWithDependencies.starPattern.values()) {
            addADependencyToStarPattern(tripleWithDependencies, innerQuery);
        }
    }
    addUnionDependencies(resp);
    return resp;
}
// could be made so that when adding a union we make sure to find the dependency
// function should be revisited
function addUnionDependencies(query) {
    if (query.union === undefined) {
        return;
    }
    //eslint-disable-next-line @typescript-eslint/prefer-for-of
    for (let i = 0; i < query.union.length; i++) {
        const union = query.union[i];
        for (const branch of union) {
            for (const starPattern of branch.starPatterns.values()) {
                for (const triple of starPattern.starPattern.values()) {
                    if (triple.dependencies === undefined) {
                        const linkedStarPattern = triple.triple.getLinkedStarPattern();
                        if (linkedStarPattern !== undefined) {
                            const dependency = query.starPatterns.get(linkedStarPattern);
                            if (dependency !== undefined) {
                                triple.dependencies = dependency;
                                continue;
                            }
                            //searchDependencyInUnion(query.union, i, triple);
                        }
                    }
                }
            }
        }
    }
}
/**
 to figure out if it make sense
function searchDependencyInUnion(unions: IQuery[][], currentBranch: number, triple: ITripleWithDependencies) {
  const linkedStarPattern = triple.triple.getLinkedStarPattern();
  if (linkedStarPattern === undefined || triple.dependencies === undefined) {
    return;
  }
  for (let i = 0; i < unions.length; i++) {
    const union = unions[i];
    if (i === currentBranch) {
      continue;
    }
    for (const branch of union) {
      const dependency = branch.starPatterns.get(linkedStarPattern);
      if (dependency !== undefined) {
        triple.dependencies = dependency;
        return;
      }
    }
  }

}
*/
function addADependencyToStarPattern(tripleWithDependencies, innerQuery) {
    const linkedStarPattern = tripleWithDependencies.triple.getLinkedStarPattern();
    if (linkedStarPattern !== undefined) {
        const dependentStarPattern = innerQuery.get(linkedStarPattern);
        if (dependentStarPattern !== undefined) {
            tripleWithDependencies.dependencies = dependentStarPattern;
        }
    }
}
var QueryHandler;
(function (QueryHandler) {
    function collectFromAlgebra(rootAlgebra, accumulatedTriples, accumatedValues, accumulatedUnion, optional) {
        sparqlalgebrajs_1.Util.recurseOperation(rootAlgebra, {
            [sparqlalgebrajs_1.Algebra.types.PATTERN]: handlePattern(accumulatedTriples, optional),
            [sparqlalgebrajs_1.Algebra.types.VALUES]: handleValues(accumatedValues),
            [sparqlalgebrajs_1.Algebra.types.UNION]: handleUnion(accumulatedUnion, optional),
            [sparqlalgebrajs_1.Algebra.types.LEFT_JOIN]: handleLeftJoin(accumulatedTriples, accumatedValues, accumulatedUnion),
            [sparqlalgebrajs_1.Algebra.types.PATH]: handlePropertyPath(accumulatedTriples, accumulatedUnion, accumatedValues, optional),
        });
    }
    QueryHandler.collectFromAlgebra = collectFromAlgebra;
    function handleLeftJoin(accumulatedTriples, accumatedValues, accumulatedUnion) {
        return (element) => {
            const joinElement = element.input;
            const requiredElements = joinElement[0];
            const optionalElements = joinElement[1];
            collectFromAlgebra(requiredElements, accumulatedTriples, accumatedValues, accumulatedUnion);
            collectFromAlgebra(optionalElements, accumulatedTriples, accumatedValues, accumulatedUnion, true);
            return false;
        };
    }
    function handlePropertyPath(accumulatedTriples, accumulatedUnion, accumatedValues, optional) {
        return (element) => {
            const path = element.predicate.type;
            if (element.predicate.type === sparqlalgebrajs_1.Algebra.types.ALT) {
                accumulatedUnion.push(handleAltPropertyPath(element.subject, element.predicate.input, element.object, accumatedValues, optional));
            }
            else if (isACardinalityPropertyPath(path)) {
                const triple = handleCardinalityPropertyPath(element, optional);
                handleDirectPropertyPath(element, accumulatedTriples, triple);
            }
            else if (path === sparqlalgebrajs_1.Algebra.types.NPS) {
                const triple = handleNegatedPropertySet(element, optional);
                handleDirectPropertyPath(element, accumulatedTriples, triple);
            }
            return true;
        };
    }
    function handleUnion(accumulatedUnion, optional) {
        return (element) => {
            const branches = element.input;
            const currentUnion = [];
            for (const branch of branches) {
                currentUnion.push(generateQuery(branch, optional));
            }
            accumulatedUnion.push(currentUnion);
            return false;
        };
    }
    function handleValues(accumatedValues) {
        return (element) => {
            const bindings = element.bindings;
            for (const binding of bindings) {
                for (const [key, term] of Object.entries(binding)) {
                    const variableName = key.substring(1);
                    const value = accumatedValues.get(variableName);
                    if (value !== undefined) {
                        value.push(term);
                    }
                    else {
                        accumatedValues.set(variableName, [term]);
                    }
                }
            }
            return false;
        };
    }
    function handlePattern(accumulatedTriples, optional) {
        return (quad) => {
            const subject = quad.subject;
            const predicate = quad.predicate;
            const object = quad.object;
            if (predicate.termType === 'NamedNode') {
                const startPattern = accumulatedTriples.get(subject.value);
                const triple = new Triple_1.Triple({
                    subject: subject.value,
                    predicate: quad.predicate.value,
                    object,
                    isOptional: optional
                });
                if (startPattern === undefined) {
                    accumulatedTriples.set(subject.value, { triples: new Map([[triple.toString(), triple]]), isVariable: subject.termType === "Variable" });
                }
                else {
                    startPattern.triples.set(triple.toString(), triple);
                }
            }
            return false;
        };
    }
    function handleCardinalityPropertyPath(element, optional) {
        const subject = element.subject;
        const object = element.object;
        const predicate = element.predicate.path.iri;
        const predicateCardinality = element.predicate.type;
        let cardinality = undefined;
        switch (predicateCardinality) {
            case sparqlalgebrajs_1.Algebra.types.ZERO_OR_MORE_PATH:
                cardinality = { min: 0, max: -1 };
                break;
            case sparqlalgebrajs_1.Algebra.types.ZERO_OR_ONE_PATH:
                cardinality = { min: 0, max: 1 };
                break;
            case sparqlalgebrajs_1.Algebra.types.ONE_OR_MORE_PATH:
                cardinality = { min: 1, max: -1 };
                break;
        }
        if (cardinality) {
            return {
                triple: new Triple_1.Triple({
                    subject: subject.value,
                    predicate: predicate.value,
                    object,
                    cardinality,
                    isOptional: optional
                }),
                isVariable: subject.termType === "Variable"
            };
        }
    }
    function handleDirectPropertyPath(element, accumulatedTriples, triple) {
        const subject = element.subject;
        const startPattern = accumulatedTriples.get(subject.value);
        if (triple !== undefined) {
            if (startPattern === undefined) {
                accumulatedTriples.set(subject.value, { isVariable: triple.isVariable, triples: new Map([[triple.triple.toString(), triple.triple]]) });
            }
            else {
                startPattern.triples.set(triple.triple.toString(), triple.triple);
            }
        }
    }
    function isACardinalityPropertyPath(predicateType) {
        return predicateType === sparqlalgebrajs_1.Algebra.types.ZERO_OR_MORE_PATH ||
            predicateType === sparqlalgebrajs_1.Algebra.types.ZERO_OR_ONE_PATH ||
            predicateType === sparqlalgebrajs_1.Algebra.types.ONE_OR_MORE_PATH;
    }
    function handleInvPath(element, subject, object, accumatedValues, optional) {
        if (element.path.type === sparqlalgebrajs_1.Algebra.types.ALT) {
            return handleAltPropertyPath(object, element.path.input, subject, accumatedValues, optional);
        }
        else {
            return handleAltPropertyPath(object, [element.path], subject, accumatedValues, optional);
        }
    }
    function handleAltPropertyPath(subject, predicates, object, accumatedValues, optional) {
        let union = [];
        for (const path of predicates) {
            const cardinality = getCardinality(path.type);
            if (cardinality !== undefined) {
                union.push(handleLinkQuery(path.path, accumatedValues, subject, object, cardinality, optional));
            }
            else if (path.type === sparqlalgebrajs_1.Algebra.types.LINK) {
                union.push(handleLinkQuery(path, accumatedValues, subject, object, undefined, optional));
            }
            else if (path.type === sparqlalgebrajs_1.Algebra.types.SEQ) {
                union.push(handleSeqPathQuery(path, accumatedValues, subject, object, optional));
            }
            else if (path.type === sparqlalgebrajs_1.Algebra.types.NPS) {
                union.push(handleNegatedPropertyQuery(path, accumatedValues, subject, object, optional));
            }
            else if (path.type === sparqlalgebrajs_1.Algebra.types.INV) {
                const invOption = handleInvPath(path, subject, object, accumatedValues, optional);
                union = union.concat(invOption);
            }
        }
        return union;
    }
    function handleSeqPath(element, accumatedValues, accumulatedTriples, accumulatedUnion, subject, object, optional) {
        const predicates = element.input;
        let currentObject = constant_1.DF.blankNode(`${predicates[0].iri.value}_${subject.value}`);
        for (let i = 0; i < predicates.length; i++) {
            const path = predicates[i];
            const currentSubject = i === 0 ? subject : currentObject;
            currentObject = i === predicates.length - 1 ? object : constant_1.DF.blankNode(`${path.iri.value}_${subject.value}`);
            if (path.type === sparqlalgebrajs_1.Algebra.types.LINK) {
                handleLink(path, accumulatedTriples, currentSubject, currentObject, undefined, optional);
            }
            else if (path.type === sparqlalgebrajs_1.Algebra.types.NPS) {
                handleNegatedPropertyLink(path, accumulatedTriples, currentSubject, currentObject, optional);
            }
            else if (path.type === sparqlalgebrajs_1.Algebra.types.ALT) {
                accumulatedUnion.push(handleAltPropertyPath(currentSubject, path.input, currentObject, accumatedValues, optional));
            }
        }
    }
    function handleSeqPathQuery(element, accumatedValues, subject, object, optional) {
        const accumulatedTriples = new Map();
        const accumulatedUnion = [];
        handleSeqPath(element, accumatedValues, accumulatedTriples, accumulatedUnion, subject, object, optional);
        return buildQuery(accumulatedTriples, accumatedValues, accumulatedUnion);
    }
    function getCardinality(nodeType) {
        switch (nodeType) {
            case sparqlalgebrajs_1.Algebra.types.ZERO_OR_MORE_PATH:
                return { min: 0, max: -1 };
            case sparqlalgebrajs_1.Algebra.types.ZERO_OR_ONE_PATH:
                return { min: 0, max: 1 };
            case sparqlalgebrajs_1.Algebra.types.ONE_OR_MORE_PATH:
                return { min: 1, max: -1 };
            default:
                return undefined;
        }
    }
    function handleLink(element, accumulatedTriples, subject, object, cardinality, optional) {
        const triple = new Triple_1.Triple({
            subject: subject.value,
            predicate: element.iri.value,
            object,
            cardinality,
            isOptional: optional
        });
        accumulatedTriples.set(subject.value, {
            triples: new Map([[triple.toString(), triple]]),
            isVariable: subject.termType === "Variable"
        });
    }
    function handleLinkQuery(element, accumatedValues, subject, object, cardinality, optional) {
        const accumulatedTriples = new Map();
        handleLink(element, accumulatedTriples, subject, object, cardinality, optional);
        return buildQuery(accumulatedTriples, accumatedValues, []);
    }
    function handleNegatedPropertyLink(element, accumulatedTriples, subject, object, optional) {
        const predicates = element.iris;
        const negatedSet = new Set();
        for (const predicate of predicates) {
            negatedSet.add(predicate.value);
        }
        const triple = new Triple_1.Triple({
            subject: subject.value,
            predicate: Triple_1.Triple.NEGATIVE_PREDICATE_SET,
            object,
            negatedSet,
            isOptional: optional
        });
        accumulatedTriples.set(subject.value, {
            triples: new Map([[triple.toString(), triple]]),
            isVariable: subject.termType === "Variable"
        });
    }
    function handleNegatedPropertyQuery(element, accumatedValues, subject, object, optional) {
        const accumulatedTriples = new Map();
        handleNegatedPropertyLink(element, accumulatedTriples, subject, object, optional);
        return buildQuery(accumulatedTriples, accumatedValues, []);
    }
    function handleNegatedPropertySet(element, optional) {
        const subject = element.subject;
        const object = element.object;
        const predicates = element.predicate.iris;
        const negatedSet = new Set();
        for (const predicate of predicates) {
            negatedSet.add(predicate.value);
        }
        return {
            triple: new Triple_1.Triple({
                subject: subject.value,
                predicate: Triple_1.Triple.NEGATIVE_PREDICATE_SET,
                object,
                negatedSet: negatedSet,
                isOptional: optional
            }),
            isVariable: subject.termType === "Variable"
        };
    }
})(QueryHandler || (QueryHandler = {}));
//# sourceMappingURL=query.js.map