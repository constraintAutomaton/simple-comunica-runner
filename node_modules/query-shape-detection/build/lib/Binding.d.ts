import { IPredicate, IShape, OneOfPathIndexed } from "./Shape";
import { IStarPatternWithDependencies, type ITriple } from "./Triple";
/**
 * A binding from a query to a shape
 */
export interface IBindings {
    /**
     * Indicate if a star pattern is contained in a shape
     * @returns {boolean} indicate if the query is contained in a shape
     */
    isFullyBounded: () => boolean;
    /**
     * Indicate that the documents linked to the shapes should be visited if there are
     * complete or partial binding
     * @returns {boolean} indicate if the documents link to the shapes should be visited
     */
    shouldVisitShape: () => boolean;
    /**
     *
     * Return the unbounded triples
     * @returns {ITriple[]} The binded triples
     */
    getUnboundedTriple: () => ITriple[];
    /**
     * Return the bindings, the value is undefined if the triple cannot be bind to the shape
     * @returns {Map<string, ITriple | undefined>} the internal bindings
     */
    getBindings: () => Map<string, ITriple | undefined>;
    /**
     * Return the bind triple
     * @returns {ITriple[]} the bind triple
     */
    getBoundTriple: () => ITriple[];
    /**
     * Return the name of the decendent star pattern if the current star pattern is contained
     * @returns {[string, string | undefined][]} the star pattern name of the decendent if the current star pattern is contained
     */
    getNestedContainedStarPatternName: () => IDependentStarPattern[];
}
export interface IDependentStarPattern {
    starPattern: string;
    shape?: string[];
    origin: string;
}
export declare enum ConstraintResult {
    INAPPLICABLE = 0,
    RESPECT = 1,
    NOT_RESPECT = 2
}
/**
 * Calculate the bindings from a shape and a query
 */
export declare class Bindings implements IBindings {
    private bindings;
    private unboundTriple;
    private fullyBounded;
    private readonly closedShape;
    private nestedContainedStarPatternName;
    private nestedContainedStarPatternNameShapesContained;
    private readonly oneOfs;
    private unionBindings;
    private shapePredicateBind;
    private strict;
    private allOptional;
    constructor(shape: IShape, starPattern: IStarPatternWithDependencies, linkedShape: Map<string, IShape>, unionStarPattern?: IStarPatternWithDependencies[][], strict?: boolean);
    private calculateBinding;
    private evaluateConstraint;
    private fillNestedContainedStarPatternName;
    private handleShapeConstraint;
    private static handleShapeType;
    isFullyBounded(): boolean;
    getUnboundedTriple(): ITriple[];
    getBindings(): Map<string, ITriple | undefined>;
    getBoundTriple(): ITriple[];
    shouldVisitShape(): boolean;
    getNestedContainedStarPatternName(): IDependentStarPattern[];
}
export declare class OneOfBinding {
    private readonly paths;
    constructor(paths: OneOfPathIndexed[]);
    get(el: string): IPredicate[] | undefined;
}
export declare class UnionBinding {
    private readonly bindings;
    readonly hasOneContained: boolean;
    readonly areAllContained: boolean;
    readonly dependentStarPattern: IDependentStarPattern[];
    constructor(shape: IShape, union: IStarPatternWithDependencies[], linkedShape: Map<string, IShape>);
    private determineHasOneAtLeastContainment;
    private determineAllContained;
}
