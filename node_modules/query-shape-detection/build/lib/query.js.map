{"version":3,"file":"query.js","sourceRoot":"","sources":["../../lib/query.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Term } from '@rdfjs/types';\nimport { Algebra, Util } from 'sparqlalgebrajs';\nimport { ITripleWithDependencies, Triple, type IStarPatternWithDependencies, ITriple } from './Triple';\nimport { ICardinality } from './Shape';\nimport { DF } from './constant';\n\ninterface IAccumulatedTriples { triples: Map<string, ITriple>, isVariable: boolean }\n/**\n * A query divided into star patterns\n */\nexport interface IQuery {\n  // star patterns indexed by subject\n  starPatterns: Map<string, IStarPatternWithDependencies>;\n  union?: IQuery[][];\n  filterExpression?: string;\n}\n\nexport function generateStarPatternUnion(union: IQuery[][], starPatternName: string): IStarPatternWithDependencies[][] {\n  const resp: IStarPatternWithDependencies[][] = [];\n  for (const unionSet of union) {\n    const currentUnionSet: IStarPatternWithDependencies[] = [];\n    for (const union of unionSet) {\n      const requestedStarPattern = union.starPatterns.get(starPatternName);\n      if (requestedStarPattern !== undefined) {\n        currentUnionSet.push(requestedStarPattern);\n      }\n    }\n    if (currentUnionSet.length > 0) {\n      resp.push(currentUnionSet)\n    }\n  }\n  return resp;\n}\n\n/**\n * Divide a query into star patterns\n * @param {Algebra.Operation} algebraQuery - the algebra of a query\n * @returns {Query} - A query divided into subject group where the predicate has to be an IRI\n * @todo add support for the bind operator\n */\nexport function generateQuery(algebraQuery: Algebra.Operation, optional?: boolean): IQuery {\n  const accumulatedTriples = new Map<string, IAccumulatedTriples>();\n  // the binding value to the value\n  const accumatedValues = new Map<string, Term[]>();\n  const accumulatedUnion: IQuery[][] = [];\n\n  QueryHandler.collectFromAlgebra(algebraQuery, accumulatedTriples, accumatedValues, accumulatedUnion, optional);\n\n  return buildQuery(accumulatedTriples, accumatedValues, accumulatedUnion);\n}\n\nfunction buildQuery(\n  tripleArgs: Map<string, IAccumulatedTriples>,\n  values: Map<string, Term[]>,\n  accumulatedUnion: IQuery[][]\n): IQuery {\n  const innerQuery = new Map<string, IStarPatternWithDependencies>();\n  const resp: IQuery = { starPatterns: innerQuery, filterExpression: \"\" };\n  if (accumulatedUnion.length > 0) {\n    resp.union = accumulatedUnion;\n  }\n\n  // generate the root star patterns\n  for (const [starPatternSubject, { triples, isVariable }] of tripleArgs) {\n    for (let triple of triples.values()) {\n      if (!Array.isArray(triple.object) && triple.object?.termType === \"Variable\") {\n        const value = values.get(triple.object.value);\n        if (value !== undefined) {\n          triple = new Triple({\n            subject: triple.subject,\n            predicate: triple.predicate,\n            object: value,\n            cardinality: triple.cardinality,\n            negatedSet: triple.negatedSet\n          });\n        }\n      }\n      const starPattern = innerQuery.get(starPatternSubject);\n\n      if (starPattern === undefined) {\n        const predicateWithDependencies: ITripleWithDependencies = { triple: triple, dependencies: undefined };\n        innerQuery.set(starPatternSubject, {\n          starPattern: new Map([\n            [triple.predicate, predicateWithDependencies]\n          ]),\n          name: starPatternSubject,\n          isVariable: isVariable,\n        });\n      } else {\n        const predicateWithDependencies: ITripleWithDependencies = { triple: triple, dependencies: undefined };\n        starPattern.starPattern.set(triple.predicate, predicateWithDependencies);\n      }\n    }\n  }\n\n  // set the dependencies of the star pattern\n  for (const starPatternWithDependencies of innerQuery.values()) {\n    for (const tripleWithDependencies of starPatternWithDependencies.starPattern.values()) {\n      addADependencyToStarPattern(tripleWithDependencies, innerQuery);\n    }\n  }\n  addUnionDependencies(resp)\n  return resp;\n}\n\n// could be made so that when adding a union we make sure to find the dependency\n// function should be revisited\nfunction addUnionDependencies(query: IQuery): void {\n  if (query.union === undefined) {\n    return;\n  }\n  //eslint-disable-next-line @typescript-eslint/prefer-for-of\n  for (let i = 0; i < query.union.length; i++) {\n    const union = query.union[i];\n    for (const branch of union) {\n      for (const starPattern of branch.starPatterns.values()) {\n        for (const triple of starPattern.starPattern.values()) {\n          if (triple.dependencies === undefined) {\n            const linkedStarPattern = triple.triple.getLinkedStarPattern();\n            if (linkedStarPattern !== undefined) {\n              const dependency = query.starPatterns.get(linkedStarPattern);\n              if (dependency !== undefined) {\n                triple.dependencies = dependency;\n                continue;\n              }\n              //searchDependencyInUnion(query.union, i, triple);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n/** \n to figure out if it make sense\nfunction searchDependencyInUnion(unions: IQuery[][], currentBranch: number, triple: ITripleWithDependencies) {\n  const linkedStarPattern = triple.triple.getLinkedStarPattern();\n  if (linkedStarPattern === undefined || triple.dependencies === undefined) {\n    return;\n  }\n  for (let i = 0; i < unions.length; i++) {\n    const union = unions[i];\n    if (i === currentBranch) {\n      continue;\n    }\n    for (const branch of union) {\n      const dependency = branch.starPatterns.get(linkedStarPattern);\n      if (dependency !== undefined) {\n        triple.dependencies = dependency;\n        return;\n      }\n    }\n  }\n\n}\n*/\n\nfunction addADependencyToStarPattern(\n  tripleWithDependencies: ITripleWithDependencies,\n  innerQuery: Map<string, IStarPatternWithDependencies>): void {\n  const linkedStarPattern = tripleWithDependencies.triple.getLinkedStarPattern();\n  if (linkedStarPattern !== undefined) {\n    const dependentStarPattern = innerQuery.get(linkedStarPattern);\n    if (dependentStarPattern !== undefined) {\n      tripleWithDependencies.dependencies = dependentStarPattern\n    }\n\n  }\n\n}\n\nnamespace QueryHandler {\n\n  export function collectFromAlgebra(rootAlgebra: Algebra.Operation, accumulatedTriples: Map<string, IAccumulatedTriples>,\n    accumatedValues: Map<string, Term[]>,\n    accumulatedUnion: IQuery[][],\n    optional?: boolean): void {\n    Util.recurseOperation(\n      rootAlgebra,\n      {\n        [Algebra.types.PATTERN]: handlePattern(accumulatedTriples, optional),\n        [Algebra.types.VALUES]: handleValues(accumatedValues),\n        [Algebra.types.UNION]: handleUnion(accumulatedUnion, optional),\n        [Algebra.types.LEFT_JOIN]: handleLeftJoin(accumulatedTriples, accumatedValues, accumulatedUnion),\n        [Algebra.types.PATH]: handlePropertyPath(accumulatedTriples, accumulatedUnion, accumatedValues, optional),\n      },\n    );\n  }\n\n  function handleLeftJoin(accumulatedTriples: Map<string, IAccumulatedTriples>,\n    accumatedValues: Map<string, Term[]>,\n    accumulatedUnion: IQuery[][]): (element: Algebra.LeftJoin) => boolean {\n    return (element: Algebra.LeftJoin): boolean => {\n      const joinElement = element.input;\n      const requiredElements = joinElement[0];\n      const optionalElements = joinElement[1];\n\n      collectFromAlgebra(requiredElements, accumulatedTriples, accumatedValues, accumulatedUnion);\n      collectFromAlgebra(optionalElements, accumulatedTriples, accumatedValues, accumulatedUnion, true);\n\n      return false;\n    }\n  }\n\n  function handlePropertyPath(\n    accumulatedTriples: Map<string,\n      IAccumulatedTriples>, accumulatedUnion: IQuery[][],\n    accumatedValues: Map<string, Term[]>,\n    optional?: boolean,\n  ): (element: Algebra.Path) => boolean {\n    return (element: Algebra.Path): boolean => {\n      const path = element.predicate.type;\n      if (element.predicate.type === Algebra.types.ALT) {\n        accumulatedUnion.push(handleAltPropertyPath(element.subject, element.predicate.input, element.object, accumatedValues, optional));\n      } else if (isACardinalityPropertyPath(path)) {\n        const triple = handleCardinalityPropertyPath(element, optional);\n        handleDirectPropertyPath(element, accumulatedTriples, triple);\n      } else if (path === Algebra.types.NPS) {\n        const triple = handleNegatedPropertySet(element, optional);\n        handleDirectPropertyPath(element, accumulatedTriples, triple);\n      }\n      return true;\n    };\n  }\n\n  function handleUnion(accumulatedUnion: IQuery[][], optional?: boolean): (element: Algebra.Union) => boolean {\n    return (element: Algebra.Union): boolean => {\n      const branches: Algebra.Operation[] = element.input;\n      const currentUnion: IQuery[] = [];\n      for (const branch of branches) {\n        currentUnion.push(generateQuery(branch, optional))\n      }\n      accumulatedUnion.push(currentUnion);\n      return false;\n    };\n  }\n\n  function handleValues(accumatedValues: Map<string, Term[]>): (element: Algebra.Values) => boolean {\n    return (element: Algebra.Values): boolean => {\n      const bindings: Record<string, Term>[] = element.bindings;\n      for (const binding of bindings) {\n        for (const [key, term] of Object.entries(binding)) {\n          const variableName = key.substring(1);\n          const value = accumatedValues.get(variableName);\n          if (value !== undefined) {\n            value.push(term);\n          } else {\n            accumatedValues.set(variableName, [term]);\n          }\n        }\n      }\n      return false;\n    }\n  }\n\n  function handlePattern(accumulatedTriples: Map<string, IAccumulatedTriples>, optional?: boolean): (element: Algebra.Pattern) => boolean {\n    return (quad: Algebra.Pattern): boolean => {\n      const subject = quad.subject as Term;\n      const predicate = quad.predicate as Term;\n      const object = quad.object as Term;\n      if (predicate.termType === 'NamedNode') {\n        const startPattern = accumulatedTriples.get(subject.value);\n        const triple: ITriple = new Triple({\n          subject: subject.value,\n          predicate: quad.predicate.value,\n          object,\n          isOptional: optional\n        });\n        if (startPattern === undefined) {\n          accumulatedTriples.set(subject.value,\n            { triples: new Map([[triple.toString(), triple]]), isVariable: subject.termType === \"Variable\" });\n        } else {\n          startPattern.triples.set(triple.toString(), triple);\n        }\n      }\n      return false;\n    };\n  }\n\n  function handleCardinalityPropertyPath(element: Algebra.Path, optional?: boolean): { triple: ITriple, isVariable: boolean } | undefined {\n    const subject = element.subject as Term;\n    const object = element.object as Term;\n    const predicate = element.predicate.path.iri;\n    const predicateCardinality = element.predicate.type;\n    let cardinality = undefined;\n    switch (predicateCardinality) {\n      case Algebra.types.ZERO_OR_MORE_PATH:\n        cardinality = { min: 0, max: -1 }\n        break;\n      case Algebra.types.ZERO_OR_ONE_PATH:\n        cardinality = { min: 0, max: 1 };\n        break;\n      case Algebra.types.ONE_OR_MORE_PATH:\n        cardinality = { min: 1, max: -1 };\n        break;\n    }\n    if (cardinality) {\n      return {\n        triple: new Triple({\n          subject: subject.value,\n          predicate: predicate.value,\n          object,\n          cardinality,\n          isOptional: optional\n        }),\n        isVariable: subject.termType === \"Variable\"\n      };\n    }\n  }\n\n  function handleDirectPropertyPath(element: Algebra.Path,\n    accumulatedTriples: Map<string, IAccumulatedTriples>,\n    triple: { triple: ITriple, isVariable: boolean } | undefined): void {\n    const subject = element.subject as Term;\n    const startPattern = accumulatedTriples.get(subject.value);\n    if (triple !== undefined) {\n      if (startPattern === undefined) {\n        accumulatedTriples.set(subject.value, { isVariable: triple.isVariable, triples: new Map([[triple.triple.toString(), triple.triple]]) });\n\n      } else {\n        startPattern.triples.set(triple.triple.toString(), triple.triple);\n      }\n    }\n  }\n\n  function isACardinalityPropertyPath(predicateType: string): boolean {\n    return predicateType === Algebra.types.ZERO_OR_MORE_PATH ||\n      predicateType === Algebra.types.ZERO_OR_ONE_PATH ||\n      predicateType === Algebra.types.ONE_OR_MORE_PATH;\n  }\n\n  function handleInvPath(element: Algebra.Inv,\n    subject: Term,\n    object: Term,\n    accumatedValues: Map<string, Term[]>,\n    optional?: boolean): IQuery[] {\n    if (element.path.type === Algebra.types.ALT) {\n      return handleAltPropertyPath(object, element.path.input, subject, accumatedValues, optional);\n    } else {\n      return handleAltPropertyPath(object, [element.path], subject, accumatedValues, optional);\n    }\n  }\n\n  function handleAltPropertyPath(\n    subject: Term,\n    predicates: Algebra.Operation[],\n    object: Term,\n    accumatedValues: Map<string, Term[]>,\n    optional?: boolean,\n  ): IQuery[] {\n    let union: IQuery[] = [];\n    for (const path of predicates) {\n      const cardinality = getCardinality(path.type);\n      if (cardinality !== undefined) {\n        union.push(handleLinkQuery(path.path, accumatedValues, subject, object, cardinality, optional));\n      } else if (path.type === Algebra.types.LINK) {\n        union.push(handleLinkQuery(path, accumatedValues, subject, object, undefined, optional));\n      } else if (path.type === Algebra.types.SEQ) {\n        union.push(handleSeqPathQuery(path, accumatedValues, subject, object, optional));\n      } else if (path.type === Algebra.types.NPS) {\n        union.push(handleNegatedPropertyQuery(path, accumatedValues, subject, object, optional));\n      } else if (path.type === Algebra.types.INV) {\n        const invOption = handleInvPath(path, subject, object, accumatedValues, optional);\n        union = union.concat(invOption);\n      }\n    }\n    return union;\n  }\n\n  function handleSeqPath(\n    element: Algebra.Seq,\n    accumatedValues: Map<string, Term[]>,\n    accumulatedTriples: Map<string, IAccumulatedTriples>,\n    accumulatedUnion: IQuery[][],\n    subject: Term,\n    object: Term,\n    optional?: boolean): void {\n    const predicates = element.input;\n    let currentObject: Term = DF.blankNode(`${predicates[0].iri.value}_${subject.value}`);\n\n    for (let i = 0; i < predicates.length; i++) {\n      const path = predicates[i];\n      const currentSubject: Term = i === 0 ? subject : currentObject;\n\n      currentObject = i === predicates.length - 1 ? object : DF.blankNode(`${path.iri.value}_${subject.value}`);\n\n      if (path.type === Algebra.types.LINK) {\n        handleLink(path, accumulatedTriples, currentSubject, currentObject, undefined, optional);\n      } else if (path.type === Algebra.types.NPS) {\n        handleNegatedPropertyLink(path, accumulatedTriples, currentSubject, currentObject, optional)\n      } else if (path.type === Algebra.types.ALT) {\n        accumulatedUnion.push(handleAltPropertyPath(currentSubject, path.input, currentObject, accumatedValues, optional));\n      }\n    }\n\n  }\n  function handleSeqPathQuery(element: Algebra.Seq, accumatedValues: Map<string, Term[]>, subject: Term, object: Term, optional?: boolean): IQuery {\n    const accumulatedTriples = new Map<string, IAccumulatedTriples>();\n    const accumulatedUnion: IQuery[][] = [];\n\n    handleSeqPath(element, accumatedValues, accumulatedTriples, accumulatedUnion, subject, object, optional);\n\n    return buildQuery(accumulatedTriples, accumatedValues, accumulatedUnion);\n  }\n\n  function getCardinality(nodeType: string): ICardinality | undefined {\n    switch (nodeType) {\n      case Algebra.types.ZERO_OR_MORE_PATH:\n        return { min: 0, max: -1 }\n      case Algebra.types.ZERO_OR_ONE_PATH:\n        return { min: 0, max: 1 };\n      case Algebra.types.ONE_OR_MORE_PATH:\n        return { min: 1, max: -1 };\n      default:\n        return undefined;\n    }\n  }\n\n  function handleLink(element: Algebra.Link,\n    accumulatedTriples: Map<string, IAccumulatedTriples>,\n    subject: Term,\n    object: Term,\n    cardinality?: ICardinality,\n    optional?: boolean\n  ): void {\n    const triple: ITriple = new Triple({\n      subject: subject.value,\n      predicate: element.iri.value,\n      object,\n      cardinality,\n      isOptional: optional\n    });\n\n    accumulatedTriples.set(subject.value,\n      {\n        triples: new Map([[triple.toString(), triple]]),\n        isVariable: subject.termType === \"Variable\"\n      });\n  }\n\n  function handleLinkQuery(\n    element: Algebra.Link,\n    accumatedValues: Map<string, Term[]>,\n    subject: Term,\n    object: Term,\n    cardinality?: ICardinality,\n    optional?: boolean,\n  ): IQuery {\n    const accumulatedTriples = new Map<string, IAccumulatedTriples>();\n    handleLink(element, accumulatedTriples, subject, object, cardinality, optional);\n    return buildQuery(accumulatedTriples, accumatedValues, []);\n  }\n\n  function handleNegatedPropertyLink(\n    element: Algebra.Nps,\n    accumulatedTriples: Map<string, IAccumulatedTriples>,\n    subject: Term,\n    object: Term,\n    optional?: boolean,\n  ): void {\n    const predicates = element.iris;\n    const negatedSet = new Set<string>();\n    for (const predicate of predicates) {\n      negatedSet.add(predicate.value);\n    }\n\n    const triple: ITriple = new Triple({\n      subject: subject.value,\n      predicate: Triple.NEGATIVE_PREDICATE_SET,\n      object,\n      negatedSet,\n      isOptional: optional\n    });\n\n    accumulatedTriples.set(subject.value,\n      {\n        triples: new Map([[triple.toString(), triple]]),\n        isVariable: subject.termType === \"Variable\"\n      });\n\n  }\n\n  function handleNegatedPropertyQuery(\n    element: Algebra.Nps,\n    accumatedValues: Map<string, Term[]>,\n    subject: Term,\n    object: Term,\n    optional?: boolean,\n  ): IQuery {\n    const accumulatedTriples = new Map<string, IAccumulatedTriples>();\n    handleNegatedPropertyLink(element, accumulatedTriples, subject, object, optional);\n    return buildQuery(accumulatedTriples, accumatedValues, []);\n  }\n\n  function handleNegatedPropertySet(element: Algebra.Path, optional?: boolean): { triple: ITriple, isVariable: boolean } | undefined {\n    const subject = element.subject as Term;\n    const object = element.object as Term;\n    const predicates = element.predicate.iris;\n    const negatedSet = new Set<string>();\n    for (const predicate of predicates) {\n      negatedSet.add(predicate.value);\n    }\n\n    return {\n      triple: new Triple({\n        subject: subject.value,\n        predicate: Triple.NEGATIVE_PREDICATE_SET,\n        object,\n        negatedSet: negatedSet,\n        isOptional: optional\n      }),\n      isVariable: subject.termType === \"Variable\"\n    };\n  }\n}\n"]}