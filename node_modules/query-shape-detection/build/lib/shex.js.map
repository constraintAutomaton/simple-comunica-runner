{"version":3,"file":"shex.js","sourceRoot":"","sources":["../../lib/shex.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport {\n  SHEX_PREDICATE,\n  SHEX_EXPRESSION,\n  IRI_FIRST_RDF_LIST,\n  SHEX_EXPRESSIONS,\n  IRI_REST_RDF_LIST,\n  SHEX_CLOSED_SHAPE,\n  RDF_TRUE,\n  SHEX_SHAPE_EXPRESSION,\n  SHEX_MAX,\n  SHEX_MIN,\n  SHEX_VALUE_EXPR,\n  SHEX_DATA_TYPE,\n  SHEX_EACH_OF,\n  SHEX_ONE_OF,\n} from './constant';\nimport type { IContraint, InconsistentPositiveAndNegativePredicateError, OneOf, IShape, IPredicate } from './Shape';\nimport { Shape, ContraintType } from './Shape';\n\n/**\n * Parse a Shex shape from a set of quads\n * @param {RDF.Stream | RDF.Quad[]} quads - Quads representing a shape\n * @param {string} shapeIri - The iri of the desired shape\n * @returns {Promise<IShape | ShapeError>} The shape\n * @todo support for `OR` statement\n */\nexport function shapeFromQuads(quads: RDF.Stream | RDF.Quad[], shapeIri: string): Promise<IShape | ShapeError> {\n  if (Array.isArray(quads)) {\n    return new Promise(resolve => {\n      resolve(shapeFromQuadArray(quads, shapeIri));\n    });\n  }\n  return shapeFromQuadStream(quads, shapeIri);\n}\n\n/**\n * Parse a Shex shape from a quad stream\n * @param {RDF.Stream} quads - Quads representing a shape\n * @param {string} shapeIri - The iri of the desired shape\n * @returns {Promise<IShape | ShapeError>} The shape\n */\nfunction shapeFromQuadStream(quadSteam: RDF.Stream, shapeIri: string): Promise<IShape | ShapeError> {\n  const mapTripleShex: IMapTripleShex = defaultMapTripleShex();\n\n  return new Promise(resolve => {\n    quadSteam.on('data', (quad: RDF.Quad) => {\n      parseShapeQuads(\n        quad,\n        mapTripleShex,\n      );\n    });\n\n    quadSteam.on('error', (error: any) => {\n      resolve(error);\n    });\n    quadSteam.on('end', () => {\n      const shape = concatShapeInfo(\n        mapTripleShex,\n        shapeIri,\n      );\n      resolve(shape);\n    });\n  });\n}\n\n/**\n * Parse a Shex shape from an array of quad\n * @param {RDF.Quad[]} quads - Quads representing a shape\n * @param {string} shapeIri - The iri of the desired shape\n * @returns {Promise<IShape | ShapeError>} The shape\n */\nfunction shapeFromQuadArray(quads: RDF.Quad[], shapeIri: string): IShape | ShapeError {\n  const mapTripleShex: IMapTripleShex = defaultMapTripleShex();\n\n  for (const quad of quads) {\n    parseShapeQuads(\n      quad,\n      mapTripleShex,\n    );\n  }\n\n  const shape = concatShapeInfo(\n    mapTripleShex,\n    shapeIri,\n  );\n  return shape;\n}\n\n/**\n * Transform an arranged set of triple into a Shape\n * @param {IMapTripleShex} mapTripleShex - Triple information to build a shape\n * @param {string} shapeIri - The iri of a shape\n * @returns {IShape | ShapeError} - The resulting shape\n */\nfunction concatShapeInfo(\n  mapTripleShex: IMapTripleShex,\n  shapeIri: string,\n): IShape | ShapeError {\n  const positivePredicates: IPredicate[] = [];\n  const negativePredicates: string[] = [];\n  const argsFunctionPredicate: IAppendPredicateArgs = {\n    mapIdPredicate: mapTripleShex.mapIdPredicate,\n    mapIriCardinalityMin: mapTripleShex.mapIriCardinalityMin,\n    mapIriCardinalityMax: mapTripleShex.mapIriCardinalityMax,\n    mapIriConstraint: mapTripleShex.mapIriConstraint,\n    mapIriDatatype: mapTripleShex.mapIriDatatype,\n    positivePredicates,\n    negativePredicates,\n    oneOf: new Map(),\n  };\n  const shapeExpr = mapTripleShex.mapIriShapeExpression.get(shapeIri);\n  let expression;\n  if (shapeExpr === undefined) {\n    expression = mapTripleShex.mapShapeExpressionId.get(shapeIri);\n  } else {\n    expression = mapTripleShex.mapShapeExpressionId.get(shapeExpr);\n  }\n  let expressions;\n  if (expression === undefined) {\n    expressions = mapTripleShex.mapLogicLinkIdExpressions.get(shapeIri);\n    if (expressions === undefined) {\n      return new ShapePoorlyFormatedError('there are no expressions in the shape');\n    }\n  } else {\n    expressions = mapTripleShex.mapLogicLinkIdExpressions.get(expression);\n  }\n  let current;\n  let next;\n  // If there is only one expression\n  if (expressions === undefined) {\n    argsFunctionPredicate.current = expression;\n    const predicateAdded = appendPredicates((argsFunctionPredicate as Required<IAppendPredicateArgs>));\n    if (!predicateAdded) {\n      return new ShapePoorlyFormatedError('there are no predicates in the shape');\n    }\n  } else if (expression !== undefined && mapTripleShex.setIriEachOf.has(expression)) {\n    current = mapTripleShex.mapPrevCurrentList.get(expressions);\n    next = mapTripleShex.mapPrevNextList.get(expressions);\n  }\n\n  const error = handleEachOf(current, next, mapTripleShex, argsFunctionPredicate);\n  if (error !== undefined) {\n    return error;\n  }\n  let isClosed;\n  if (shapeExpr === undefined) {\n    isClosed = mapTripleShex.mapShapeExpressionClosedShape.get(shapeIri);\n  } else {\n    isClosed = mapTripleShex.mapShapeExpressionClosedShape.get(shapeExpr);\n  }\n  try {\n    let oneOfs: OneOf[] = [];\n    for (const currentOneOf of argsFunctionPredicate.oneOf.values()) {\n      const oneOf: OneOf = [];\n      for (const currentPath of currentOneOf) {\n        const deleteDuplicate = new Map(currentPath.map((predicate) => [predicate.name, predicate]));\n        oneOf.push(Array.from(deleteDuplicate.values()));\n      }\n      oneOfs.push(oneOf);\n    }\n    oneOfs = deleteIdenticalBranch(oneOfs)\n    return new Shape({\n      name: shapeIri,\n      positivePredicates: positivePredicates,\n      negativePredicates,\n      closed: isClosed,\n      oneOf: oneOfs,\n    });\n  } catch (error: unknown) {\n    return error as ShapeError;\n  }\n}\n\n/**\n * Interpret an RDF term of a constraint into an object\n * @param {RDF.Term | undefined} constraint - The constraint RDF term\n * @param {Map<string, string>} mapIriDatatype - A map of IRI and data type\n * @returns {IContraint | undefined} - The constraint or undefined if the constraint is not supported\n */\nfunction interpretConstraint(\n  constraint: RDF.Term | undefined,\n  mapIriDatatype: Map<string, string>,\n): IContraint | undefined {\n  if (constraint === undefined) {\n    return undefined;\n  }\n\n  if (constraint.termType === 'NamedNode') {\n    return {\n      value: new Set([constraint.value]),\n      type: ContraintType.SHAPE,\n    };\n  }\n\n  if (constraint.termType === 'BlankNode') {\n    const dataType = mapIriDatatype.get(constraint.value);\n    if (dataType !== undefined) {\n      return {\n        value: new Set([dataType]),\n        type: ContraintType.TYPE,\n      };\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Add the predicate to the predicat lists\n * @param {Required<IAppendPredicateArgs>} args - Argument to build a predicate\n * @returns {boolean} - return true if the predicate was added\n */\nfunction appendPredicates(\n  args: Required<IAppendPredicateArgs>,\n): boolean {\n  const predicate = args.mapIdPredicate.get(args.current);\n  if (predicate !== undefined) {\n    const min = args.mapIriCardinalityMin.get(args.current);\n    const max = args.mapIriCardinalityMax.get(args.current);\n    if (min === max && min === 0) {\n      args.negativePredicates.push(predicate);\n    } else {\n      const constraintIri = args.mapIriConstraint.get(args.current);\n      const constraint = interpretConstraint(constraintIri, args.mapIriDatatype);\n      args.positivePredicates.push({\n        name: predicate,\n        cardinality: {\n          min: min ?? 1,\n          max: max ?? 1,\n        },\n        constraint,\n      });\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction handleOneOf(\n  iri: string,\n  index: string,\n  mapTripleShex: IMapTripleShex,\n  prevArgsFunctionPredicate: IAppendPredicateArgs,\n  eachOf: boolean): undefined | ShapePoorlyFormatedError {\n  const positivePredicates: IPredicate[] = [];\n  const negativePredicates: string[] = [];\n  const argsFunctionPredicate: IAppendPredicateArgs = {\n    mapIdPredicate: mapTripleShex.mapIdPredicate,\n    mapIriCardinalityMin: mapTripleShex.mapIriCardinalityMin,\n    mapIriCardinalityMax: mapTripleShex.mapIriCardinalityMax,\n    mapIriConstraint: mapTripleShex.mapIriConstraint,\n    mapIriDatatype: mapTripleShex.mapIriDatatype,\n    positivePredicates,\n    negativePredicates,\n    oneOf: new Map()\n  };\n  const expressions = mapTripleShex.mapLogicLinkIdExpressions.get(iri);\n  // we don't really support validation of format\n  /* istanbul ignore next */\n  if (expressions === undefined) {\n    return new ShapePoorlyFormatedError('There are no expressions in a one of');\n  }\n\n  let current = mapTripleShex.mapPrevCurrentList.get(expressions);\n  let next = mapTripleShex.mapPrevNextList.get(expressions);\n  while (current !== undefined) {\n    if (!mapTripleShex.setIriOneOf.has(current) && !mapTripleShex.setIriEachOf.has(current)) {\n      const error = handleEachOf(current, next, mapTripleShex, argsFunctionPredicate);\n      // we don't really support validation of format\n      /* istanbul ignore next */\n      if (error !== undefined) {\n        return error;\n      }\n    } else {\n      handleOneOf(current, iri, mapTripleShex, prevArgsFunctionPredicate, mapTripleShex.setIriEachOf.has(current));\n    }\n    // we don't really support validation of format\n    /* istanbul ignore next */\n    if (next === undefined) {\n      return new ShapePoorlyFormatedError('An RDF list is poorly defined');\n    }\n\n    current = mapTripleShex.mapPrevCurrentList.get(next);\n    next = mapTripleShex.mapPrevNextList.get(next);\n  }\n  const currentOneOf = prevArgsFunctionPredicate.oneOf.get(index);\n  if (currentOneOf === undefined) {\n    if (!eachOf) {\n      prevArgsFunctionPredicate.oneOf.set(index, Array.from(argsFunctionPredicate.positivePredicates.values()).map((predicate) => [predicate]));\n    } else {\n      prevArgsFunctionPredicate.oneOf.set(index, [Array.from(argsFunctionPredicate.positivePredicates.values())]);\n    }\n  } else {\n    if (!eachOf) {\n      for (const value of Array.from(argsFunctionPredicate.positivePredicates.values())) {\n        currentOneOf.push([value]);\n      }\n    } else {\n      currentOneOf.push(Array.from(argsFunctionPredicate.positivePredicates.values()));\n\n    }\n  }\n}\n\nfunction handleEachOf(\n  current: string | undefined,\n  next: string | undefined,\n  mapTripleShex: IMapTripleShex,\n  argsFunctionPredicate: IAppendPredicateArgs): undefined | ShapePoorlyFormatedError {\n  // Traverse the RDF list\n  while (current !== undefined) {\n    if (!mapTripleShex.setIriOneOf.has(current)) {\n      argsFunctionPredicate.current = current;\n      appendPredicates((argsFunctionPredicate as Required<IAppendPredicateArgs>));\n    } else {\n      handleOneOf(current, current, mapTripleShex, argsFunctionPredicate, mapTripleShex.setIriEachOf.has(current));\n    }\n\n    if (next === undefined) {\n      return new ShapePoorlyFormatedError('An RDF list is poorly defined');\n    }\n\n    current = mapTripleShex.mapPrevCurrentList.get(next);\n    next = mapTripleShex.mapPrevNextList.get(next);\n  }\n}\n\nfunction deleteIdenticalBranch(oneOfs: OneOf[]): OneOf[] {\n\n  for (let i = 0; i < oneOfs.length; ++i) {\n    const identicalIndex = new Set<number>();\n    const indexed = new Set<string>();\n    const oneOf = oneOfs[i];\n    for (let j = 0; j < oneOf.length; ++j) {\n      const stringElement = JSON.stringify(oneOf[j], (key, value) => {\n        if (key === \"value\") {\n          return Array.from(value);\n        }\n        return value\n      })\n      if (indexed.has(stringElement)) {\n        identicalIndex.add(j);\n      }\n      indexed.add(stringElement);\n    }\n    oneOfs[i] = oneOfs[i].filter((_, k) => {\n      return !identicalIndex.has(k);\n    });\n  }\n\n  return oneOfs;\n}\n\n/**\n * Parse the quad into the ShEx map object\n * @param {RDF.Quad} quad - A quad\n * @param {IMapTripleShex} mapTripleShex - A map of ShEx shape information\n */\nfunction parseShapeQuads(\n  quad: RDF.Quad,\n  mapTripleShex: IMapTripleShex,\n): void {\n  if (quad.predicate.equals(SHEX_PREDICATE)) {\n    mapTripleShex.mapIdPredicate.set(quad.subject.value, quad.object.value);\n  }\n  if (quad.predicate.equals(IRI_FIRST_RDF_LIST)) {\n    mapTripleShex.mapPrevCurrentList.set(quad.subject.value, quad.object.value);\n  }\n  if (quad.predicate.equals(IRI_REST_RDF_LIST)) {\n    mapTripleShex.mapPrevNextList.set(quad.subject.value, quad.object.value);\n  }\n  if (quad.predicate.equals(SHEX_EXPRESSIONS)) {\n    mapTripleShex.mapLogicLinkIdExpressions.set(quad.subject.value, quad.object.value);\n  }\n  if (quad.predicate.equals(SHEX_EXPRESSION)) {\n    mapTripleShex.mapShapeExpressionId.set(quad.subject.value, quad.object.value);\n  }\n  if (quad.predicate.equals(SHEX_CLOSED_SHAPE)) {\n    mapTripleShex.mapShapeExpressionClosedShape.set(quad.subject.value, quad.object.equals(RDF_TRUE));\n  }\n  if (quad.predicate.equals(SHEX_SHAPE_EXPRESSION)) {\n    mapTripleShex.mapIriShapeExpression.set(quad.subject.value, quad.object.value);\n  }\n  if (quad.predicate.equals(SHEX_MAX)) {\n    mapTripleShex.mapIriCardinalityMax.set(quad.subject.value, Number(quad.object.value));\n  }\n  if (quad.predicate.equals(SHEX_MIN)) {\n    mapTripleShex.mapIriCardinalityMin.set(quad.subject.value, Number(quad.object.value));\n  }\n  if (quad.predicate.equals(SHEX_VALUE_EXPR)) {\n    mapTripleShex.mapIriConstraint.set(quad.subject.value, quad.object);\n  }\n  if (quad.predicate.equals(SHEX_DATA_TYPE)) {\n    mapTripleShex.mapIriDatatype.set(quad.subject.value, quad.object.value);\n  }\n  if (quad.object.equals(SHEX_EACH_OF)) {\n    mapTripleShex.setIriEachOf.add(quad.subject.value);\n  }\n  if (quad.object.equals(SHEX_ONE_OF)) {\n    mapTripleShex.setIriOneOf.add(quad.subject.value);\n  }\n}\n/**\n * An error to indicate that the shape is poorly formated\n */\nexport class ShapePoorlyFormatedError extends Error {\n  public constructor(message: string) {\n    super(message);\n\n    Object.setPrototypeOf(this, ShapePoorlyFormatedError.prototype);\n  }\n}\n\ntype ShapeError = ShapePoorlyFormatedError | InconsistentPositiveAndNegativePredicateError;\n\ninterface IMapTripleShex {\n  mapIdPredicate: Map<string, string>;\n  mapPrevCurrentList: Map<string, string>;\n  mapLogicLinkIdExpressions: Map<string, string>;\n  mapShapeExpressionId: Map<string, string>;\n  mapPrevNextList: Map<string, string>;\n  mapShapeExpressionClosedShape: Map<string, boolean>;\n  mapIriShapeExpression: Map<string, string>;\n  mapIriCardinalityMax: Map<string, number>;\n  mapIriCardinalityMin: Map<string, number>;\n  mapIriConstraint: Map<string, RDF.Term>;\n  mapIriDatatype: Map<string, string>;\n  setIriEachOf: Set<string>;\n  setIriOneOf: Set<string>;\n}\n\ninterface IAppendPredicateArgs {\n  mapIdPredicate: Map<string, string>;\n  mapIriCardinalityMin: Map<string, number>;\n  mapIriCardinalityMax: Map<string, number>;\n  mapIriConstraint: Map<string, RDF.Term>;\n  mapIriDatatype: Map<string, string>;\n  positivePredicates: IPredicate[];\n  negativePredicates: string[];\n  oneOf: Map<string, OneOf>;\n  current?: string;\n}\n\nfunction defaultMapTripleShex(): IMapTripleShex {\n  return {\n    mapIdPredicate: new Map(),\n    mapPrevCurrentList: new Map(),\n    mapLogicLinkIdExpressions: new Map(),\n    mapShapeExpressionId: new Map(),\n    mapPrevNextList: new Map(),\n    mapShapeExpressionClosedShape: new Map(),\n    mapIriShapeExpression: new Map(),\n    mapIriCardinalityMax: new Map(),\n    mapIriCardinalityMin: new Map(),\n    mapIriConstraint: new Map(),\n    mapIriDatatype: new Map(),\n    setIriEachOf: new Set(),\n    setIriOneOf: new Set()\n  };\n}\n"]}