{"version":3,"file":"Shape.js","sourceRoot":"","sources":["../../lib/Shape.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * A shape interface\n */\nexport interface IShape extends IShapeObj {\n  /**\n   * Convert a shape to an object\n   * @returns {IShapeObj}\n   */\n  toObject: () => IShapeObj;\n  /**\n   * Get the information about a predicate\n   * @param {string} predicate - the predicate\n   * @returns {IPredicate | undefined} - the information about the predicate or undefined if it is not in the shape\n   */\n  get: (predicate: string) => IPredicate | undefined;\n  /**\n   * Get all the predicates with all their information\n   * @returns {IPredicate[]} - all the predicates with extra information\n   */\n  getAll: () => IPredicate[];\n  /**\n   * get the IRIs of the shape necessary for the constraint\n   * @returns {Set<string>} - IRIs of the shape necessary for the constraint\n   */\n  getLinkedShapeIri: () => Set<string>;\n  oneOf: OneOf[];\n  oneOfIndexed: OneOfIndexed[];\n}\n\n/**\n * A predicate\n */\nexport interface IPredicate {\n  name: string;\n  constraint?: IContraint;\n  cardinality?: ICardinality;\n  negative?: boolean;\n  optional?: boolean;\n}\n/**\n * A constraint\n */\nexport interface IContraint {\n  value: Set<string>;\n  type: ContraintType;\n}\n/**\n * A cardinality\n */\nexport interface ICardinality {\n  min: number;\n  // If the value is -1 then there is no limit\n  max: number;\n}\n\n/**\n * A constraint type\n */\nexport const enum ContraintType {\n  // Is bound to another shape\n  SHAPE,\n  // Is bound by an RDF type\n  TYPE\n}\n/**\n * A simple Shape object\n */\nexport interface IShapeObj {\n  name: string;\n  closed: boolean;\n  positivePredicates: string[];\n  negativePredicates?: string[];\n  oneOf?: OneOf[];\n  oneOfIndexed?: OneOfIndexed[];\n}\n\n/**\n * The argument to generate a {Shape} instance\n */\nexport interface IShapeArgs {\n  name: string;\n  positivePredicates: (IPredicate | string)[];\n  negativePredicates?: (IPredicate | string)[];\n  linkedShapeIri?: string[]\n  closed?: boolean;\n  oneOf?: OneOf[];\n}\n\nexport type OneOf = OneOfPath[];\nexport type OneOfPath = IPredicate[];\n\nexport type OneOfPathIndexed = Map<string, IPredicate>;\nexport type OneOfIndexed = OneOfPathIndexed[];\n\n/**\n * A shape\n */\nexport class Shape implements IShape {\n  public readonly name: string;\n  public readonly positivePredicates: string[];\n  public readonly negativePredicates: string[];\n  public readonly closed: boolean;\n  public readonly linkedShapeIri: Set<string>;\n  // All the predicate with extra information\n  private readonly predicates = new Map<string, IPredicate>();\n  public readonly oneOf: OneOf[];\n  public readonly oneOfIndexed: OneOfIndexed[] = [];\n\n  /**\n   *\n   * @param {IShapeArgs} args - The argument to build a shape\n   */\n  public constructor({ name, positivePredicates, negativePredicates, closed, oneOf }: IShapeArgs) {\n    this.name = name;\n    this.closed = closed ?? false;\n    this.oneOf = oneOf ? oneOf : [];\n    const linkedShapeIri = new Set<string>();\n    for (const oneOf of this.oneOf) {\n      const currentOneOf: OneOfIndexed = [];\n      for (const oneOfPath of oneOf) {\n        const currentOneOfPath: OneOfPathIndexed = new Map(oneOfPath.map((predicate) => [predicate.name, predicate]));\n        currentOneOf.push(currentOneOfPath);\n      }\n      this.oneOfIndexed?.push(currentOneOf);\n    }\n\n    this.positivePredicates = positivePredicates.map(val => {\n      if (typeof val === 'string') {\n        return val;\n      }\n      return val.name;\n    });\n    this.negativePredicates = negativePredicates === undefined ?\n      [] :\n      negativePredicates.map(val => {\n        if (typeof val === 'string') {\n          return val;\n        }\n        return val.name;\n      });\n\n    this.validatePredicates();\n\n    for (const predicate of positivePredicates) {\n      if (typeof predicate === 'string') {\n        this.predicates.set(predicate, { name: predicate });\n      } else {\n        if (predicate.constraint !== undefined && predicate?.constraint.type === ContraintType.SHAPE) {\n          for (const value of predicate.constraint.value) {\n            if (value !== name) {\n              linkedShapeIri.add(value);\n            }\n          }\n        }\n        this.predicates.set(predicate.name,\n          {\n            ...predicate,\n            optional: predicate?.cardinality?.min === 0,\n          });\n      }\n    }\n\n    for (const paths of this.oneOf) {\n      for (const path of paths) {\n        for (const predicate of path) {\n          if (predicate.constraint !== undefined && predicate?.constraint.type === ContraintType.SHAPE) {\n            for (const value of predicate.constraint.value) {\n              if (value !== name) {\n                linkedShapeIri.add(value);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    this.linkedShapeIri = linkedShapeIri;\n\n    for (const predicate of negativePredicates ?? []) {\n      if (typeof predicate === 'string') {\n        this.predicates.set(predicate, { name: predicate, negative: true });\n      } else {\n        this.predicates.set(predicate.name, { ...predicate, negative: true });\n      }\n    }\n\n    Object.freeze(this.name);\n    Object.freeze(this.positivePredicates);\n    Object.freeze(this.negativePredicates);\n    Object.freeze(this.predicates);\n    Object.freeze(this.closed);\n    Object.freeze(this.oneOf);\n    Object.freeze(this.oneOfIndexed);\n    Object.freeze(this);\n  }\n\n  /**\n   * Validate if the shape don't have inconsistencies with the positive and negative properties\n   * @throws {InconsistentPositiveAndNegativePredicateError}\n   */\n  private validatePredicates(): void {\n    const setNegativePredicates = new Set(this.negativePredicates);\n    for (const predicate of this.positivePredicates) {\n      if (setNegativePredicates.has(predicate)) {\n        throw new InconsistentPositiveAndNegativePredicateError(\n          `the predicate ${predicate} is defined in the positive and the negative property`,\n        );\n      }\n    }\n  }\n\n  public toObject(): IShapeObj {\n    return {\n      name: this.name,\n      closed: this.closed,\n      positivePredicates: this.positivePredicates,\n      negativePredicates: this.negativePredicates,\n    };\n  }\n\n  public get(predicate: string): IPredicate | undefined {\n    return this.predicates.get(predicate);\n  }\n\n  public getAll(): IPredicate[] {\n    return [...this.predicates.values()];\n  }\n\n  public getLinkedShapeIri(): Set<string> {\n    return this.linkedShapeIri;\n  }\n}\n/**\n * An error to indicate that there is an inconsistency with the positive and negative properties\n */\nexport class InconsistentPositiveAndNegativePredicateError extends Error {\n  public constructor(message: string) {\n    super(message);\n\n    Object.setPrototypeOf(this, InconsistentPositiveAndNegativePredicateError.prototype);\n  }\n}\n\n"]}