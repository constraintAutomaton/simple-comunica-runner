/**
 * A shape interface
 */
export interface IShape extends IShapeObj {
    /**
     * Convert a shape to an object
     * @returns {IShapeObj}
     */
    toObject: () => IShapeObj;
    /**
     * Get the information about a predicate
     * @param {string} predicate - the predicate
     * @returns {IPredicate | undefined} - the information about the predicate or undefined if it is not in the shape
     */
    get: (predicate: string) => IPredicate | undefined;
    /**
     * Get all the predicates with all their information
     * @returns {IPredicate[]} - all the predicates with extra information
     */
    getAll: () => IPredicate[];
    /**
     * get the IRIs of the shape necessary for the constraint
     * @returns {Set<string>} - IRIs of the shape necessary for the constraint
     */
    getLinkedShapeIri: () => Set<string>;
    oneOf: OneOf[];
    oneOfIndexed: OneOfIndexed[];
}
/**
 * A predicate
 */
export interface IPredicate {
    name: string;
    constraint?: IContraint;
    cardinality?: ICardinality;
    negative?: boolean;
    optional?: boolean;
}
/**
 * A constraint
 */
export interface IContraint {
    value: Set<string>;
    type: ContraintType;
}
/**
 * A cardinality
 */
export interface ICardinality {
    min: number;
    max: number;
}
/**
 * A constraint type
 */
export declare const enum ContraintType {
    SHAPE = 0,
    TYPE = 1
}
/**
 * A simple Shape object
 */
export interface IShapeObj {
    name: string;
    closed: boolean;
    positivePredicates: string[];
    negativePredicates?: string[];
    oneOf?: OneOf[];
    oneOfIndexed?: OneOfIndexed[];
}
/**
 * The argument to generate a {Shape} instance
 */
export interface IShapeArgs {
    name: string;
    positivePredicates: (IPredicate | string)[];
    negativePredicates?: (IPredicate | string)[];
    linkedShapeIri?: string[];
    closed?: boolean;
    oneOf?: OneOf[];
}
export type OneOf = OneOfPath[];
export type OneOfPath = IPredicate[];
export type OneOfPathIndexed = Map<string, IPredicate>;
export type OneOfIndexed = OneOfPathIndexed[];
/**
 * A shape
 */
export declare class Shape implements IShape {
    readonly name: string;
    readonly positivePredicates: string[];
    readonly negativePredicates: string[];
    readonly closed: boolean;
    readonly linkedShapeIri: Set<string>;
    private readonly predicates;
    readonly oneOf: OneOf[];
    readonly oneOfIndexed: OneOfIndexed[];
    /**
     *
     * @param {IShapeArgs} args - The argument to build a shape
     */
    constructor({ name, positivePredicates, negativePredicates, closed, oneOf }: IShapeArgs);
    /**
     * Validate if the shape don't have inconsistencies with the positive and negative properties
     * @throws {InconsistentPositiveAndNegativePredicateError}
     */
    private validatePredicates;
    toObject(): IShapeObj;
    get(predicate: string): IPredicate | undefined;
    getAll(): IPredicate[];
    getLinkedShapeIri(): Set<string>;
}
/**
 * An error to indicate that there is an inconsistency with the positive and negative properties
 */
export declare class InconsistentPositiveAndNegativePredicateError extends Error {
    constructor(message: string);
}
