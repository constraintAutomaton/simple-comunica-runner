"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InconsistentPositiveAndNegativePredicateError = exports.Shape = exports.ContraintType = void 0;
/**
 * A constraint type
 */
var ContraintType;
(function (ContraintType) {
    // Is bound to another shape
    ContraintType[ContraintType["SHAPE"] = 0] = "SHAPE";
    // Is bound by an RDF type
    ContraintType[ContraintType["TYPE"] = 1] = "TYPE";
})(ContraintType || (exports.ContraintType = ContraintType = {}));
/**
 * A shape
 */
class Shape {
    name;
    positivePredicates;
    negativePredicates;
    closed;
    linkedShapeIri;
    // All the predicate with extra information
    predicates = new Map();
    oneOf;
    oneOfIndexed = [];
    /**
     *
     * @param {IShapeArgs} args - The argument to build a shape
     */
    constructor({ name, positivePredicates, negativePredicates, closed, oneOf }) {
        this.name = name;
        this.closed = closed ?? false;
        this.oneOf = oneOf ? oneOf : [];
        const linkedShapeIri = new Set();
        for (const oneOf of this.oneOf) {
            const currentOneOf = [];
            for (const oneOfPath of oneOf) {
                const currentOneOfPath = new Map(oneOfPath.map((predicate) => [predicate.name, predicate]));
                currentOneOf.push(currentOneOfPath);
            }
            this.oneOfIndexed?.push(currentOneOf);
        }
        this.positivePredicates = positivePredicates.map(val => {
            if (typeof val === 'string') {
                return val;
            }
            return val.name;
        });
        this.negativePredicates = negativePredicates === undefined ?
            [] :
            negativePredicates.map(val => {
                if (typeof val === 'string') {
                    return val;
                }
                return val.name;
            });
        this.validatePredicates();
        for (const predicate of positivePredicates) {
            if (typeof predicate === 'string') {
                this.predicates.set(predicate, { name: predicate });
            }
            else {
                if (predicate.constraint !== undefined && predicate?.constraint.type === 0 /* ContraintType.SHAPE */) {
                    for (const value of predicate.constraint.value) {
                        if (value !== name) {
                            linkedShapeIri.add(value);
                        }
                    }
                }
                this.predicates.set(predicate.name, {
                    ...predicate,
                    optional: predicate?.cardinality?.min === 0,
                });
            }
        }
        for (const paths of this.oneOf) {
            for (const path of paths) {
                for (const predicate of path) {
                    if (predicate.constraint !== undefined && predicate?.constraint.type === 0 /* ContraintType.SHAPE */) {
                        for (const value of predicate.constraint.value) {
                            if (value !== name) {
                                linkedShapeIri.add(value);
                            }
                        }
                    }
                }
            }
        }
        this.linkedShapeIri = linkedShapeIri;
        for (const predicate of negativePredicates ?? []) {
            if (typeof predicate === 'string') {
                this.predicates.set(predicate, { name: predicate, negative: true });
            }
            else {
                this.predicates.set(predicate.name, { ...predicate, negative: true });
            }
        }
        Object.freeze(this.name);
        Object.freeze(this.positivePredicates);
        Object.freeze(this.negativePredicates);
        Object.freeze(this.predicates);
        Object.freeze(this.closed);
        Object.freeze(this.oneOf);
        Object.freeze(this.oneOfIndexed);
        Object.freeze(this);
    }
    /**
     * Validate if the shape don't have inconsistencies with the positive and negative properties
     * @throws {InconsistentPositiveAndNegativePredicateError}
     */
    validatePredicates() {
        const setNegativePredicates = new Set(this.negativePredicates);
        for (const predicate of this.positivePredicates) {
            if (setNegativePredicates.has(predicate)) {
                throw new InconsistentPositiveAndNegativePredicateError(`the predicate ${predicate} is defined in the positive and the negative property`);
            }
        }
    }
    toObject() {
        return {
            name: this.name,
            closed: this.closed,
            positivePredicates: this.positivePredicates,
            negativePredicates: this.negativePredicates,
        };
    }
    get(predicate) {
        return this.predicates.get(predicate);
    }
    getAll() {
        return [...this.predicates.values()];
    }
    getLinkedShapeIri() {
        return this.linkedShapeIri;
    }
}
exports.Shape = Shape;
/**
 * An error to indicate that there is an inconsistency with the positive and negative properties
 */
class InconsistentPositiveAndNegativePredicateError extends Error {
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, InconsistentPositiveAndNegativePredicateError.prototype);
    }
}
exports.InconsistentPositiveAndNegativePredicateError = InconsistentPositiveAndNegativePredicateError;
//# sourceMappingURL=Shape.js.map