import type { Term } from '@rdfjs/types';
import { ICardinality } from './Shape';
/**
 * The information to create a query from a star pattern
 */
export interface IStarPatternWithDependencies {
    starPattern: Map<string, ITripleWithDependencies>;
    filterExpression?: string;
    name: string;
    isVariable: boolean;
}
export interface ITripleWithDependencies {
    triple: ITriple;
    dependencies?: IStarPatternWithDependencies;
}
/**
 * A Triple interface
 */
export interface ITriple extends ITripleArgs {
    toObject: () => ITripleArgs;
    getLinkedStarPattern: () => string | undefined;
    toString: () => string;
}
/**
 * The type of alignment
 */
export declare const enum AlignmentType {
    WEAK = 0,
    STRONG = 1,
    None = 2
}
/**
 * A Triple object
 */
export interface ITripleArgs {
    subject: string;
    predicate: string;
    object: Term | Term[];
    isOptional?: boolean;
    cardinality?: ICardinality;
    negatedSet?: Set<string>;
}
/**
 * A Triple
 */
export declare class Triple implements ITriple {
    /**
   * Indicate that the predicate can be anything.
   * It is used for the "NegatedPropertySet"
   * https://www.w3.org/TR/sparql11-query/#propertypaths
   *
   * The negatedSet property must be checked for any analysis
   */
    static readonly NEGATIVE_PREDICATE_SET = "*";
    readonly predicate: string;
    readonly subject: string;
    readonly object: Term | Term[];
    readonly cardinality?: ICardinality;
    readonly negatedSet?: Set<string>;
    readonly isOptional: boolean;
    /**
     *
     * @param {ITripleArgs} tripleObject - A triple object
     */
    constructor({ subject, predicate, object, cardinality, negatedSet: negative, isOptional }: ITripleArgs);
    /**
     * Return a triple object
     * @returns {ITripleArgs} a Triple object
     */
    toObject(): ITripleArgs;
    getLinkedStarPattern(): string | undefined;
    toString(): string;
}
