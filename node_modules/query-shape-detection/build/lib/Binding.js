"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnionBinding = exports.OneOfBinding = exports.Bindings = exports.ConstraintResult = void 0;
const Triple_1 = require("./Triple");
var ConstraintResult;
(function (ConstraintResult) {
    ConstraintResult[ConstraintResult["INAPPLICABLE"] = 0] = "INAPPLICABLE";
    ConstraintResult[ConstraintResult["RESPECT"] = 1] = "RESPECT";
    ConstraintResult[ConstraintResult["NOT_RESPECT"] = 2] = "NOT_RESPECT";
})(ConstraintResult || (exports.ConstraintResult = ConstraintResult = {}));
/**
 * Calculate the bindings from a shape and a query
 */
class Bindings {
    // indexed by predicate
    bindings = new Map();
    unboundTriple = [];
    fullyBounded = false;
    closedShape;
    nestedContainedStarPatternName = [];
    nestedContainedStarPatternNameShapesContained = new Map();
    oneOfs;
    unionBindings = [];
    shapePredicateBind = new Map();
    strict;
    allOptional = true;
    constructor(shape, starPattern, linkedShape, unionStarPattern, strict) {
        this.strict = strict ?? false;
        this.closedShape = shape.closed;
        for (const { triple } of starPattern.starPattern.values()) {
            this.bindings.set(triple.predicate, undefined);
            this.allOptional = this.allOptional && triple.isOptional === true;
        }
        for (const predicate of shape.getAll()) {
            this.shapePredicateBind.set(predicate.name, false);
        }
        this.oneOfs = shape.oneOfIndexed.map((oneOfs) => new OneOfBinding(oneOfs));
        this.calculateBinding(shape, starPattern, linkedShape, unionStarPattern ?? []);
        // delete duplicate
        this.unboundTriple = Array.from(new Set(this.unboundTriple));
    }
    calculateBinding(shape, starPattern, linkedShape, unionStarPattern) {
        for (const union of unionStarPattern) {
            this.unionBindings.push(new UnionBinding(shape, union, linkedShape));
        }
        const negatedTriples = [];
        for (const { triple, dependencies } of starPattern.starPattern.values()) {
            if (!this.closedShape) {
                this.bindings.set(triple.predicate, triple);
                continue;
            }
            if (triple.predicate === Triple_1.Triple.NEGATIVE_PREDICATE_SET) {
                negatedTriples.push(triple);
                continue;
            }
            const singlePredicate = shape.get(triple.predicate);
            let predicates = [];
            // check if the triple match a disjunction
            for (const oneOfBinding of this.oneOfs) {
                const predicatesOneOf = oneOfBinding.get(triple.predicate);
                if (predicatesOneOf !== undefined) {
                    predicates = predicates.concat(predicatesOneOf);
                }
            }
            if (singlePredicate === undefined &&
                predicates.length === 0
                && triple.isOptional !== true &&
                !this.strict) {
                this.unboundTriple.push(triple);
            }
            else {
                if (singlePredicate !== undefined) {
                    predicates.push(singlePredicate);
                }
                this.evaluateConstraint(predicates, triple, linkedShape, shape, dependencies);
            }
        }
        // negative triple in a strict containment mean that the we can take any values
        // see paper https://link.springer.com/chapter/10.1007/978-3-319-25007-6_1
        if (!this.strict) {
            for (const triple of negatedTriples) {
                let hasBind = false;
                for (const [predicate, isBind] of this.shapePredicateBind) {
                    if (!isBind && !triple.negatedSet?.has(predicate)) {
                        this.bindings.set(triple.predicate, triple);
                        this.shapePredicateBind.set(predicate, true);
                        hasBind = true;
                        continue;
                    }
                }
                if (!hasBind) {
                    this.unboundTriple.push(triple);
                }
            }
        }
        if (shape.closed === false) {
            this.fullyBounded = starPattern.starPattern.size !== 0;
        }
        else {
            let boundedUnion = true;
            for (const unionBinding of this.unionBindings) {
                boundedUnion = ((unionBinding.hasOneContained && !this.strict) ||
                    (this.strict && unionBinding.areAllContained)) && boundedUnion;
            }
            this.fullyBounded = this.unboundTriple.length === 0 && starPattern.starPattern.size !== 0 && boundedUnion;
        }
        if (this.fullyBounded) {
            const cycle = new Set();
            const rejectedValues = new Set();
            const result = new Map();
            this.fillNestedContainedStarPatternName(starPattern, cycle, starPattern.name, rejectedValues, result);
            for (const starPattern of rejectedValues) {
                result.delete(starPattern);
            }
            let nestedContainedStarPatternName = [];
            for (const nestedConstrainStarPattern of result.values()) {
                nestedContainedStarPatternName = nestedContainedStarPatternName.concat(nestedConstrainStarPattern);
            }
            // delete duplicate
            nestedContainedStarPatternName = Array.from(new Set(nestedContainedStarPatternName));
            this.nestedContainedStarPatternName = nestedContainedStarPatternName
                .map((starPatternName) => {
                return {
                    shape: this.nestedContainedStarPatternNameShapesContained.get(starPatternName),
                    starPattern: starPatternName,
                    origin: starPattern.name
                };
            });
            for (const unionBinding of this.unionBindings) {
                this.nestedContainedStarPatternName = this.nestedContainedStarPatternName.concat(unionBinding.dependentStarPattern);
            }
            // delete duplicate
            this.nestedContainedStarPatternName = Array.from(new Set(this.nestedContainedStarPatternName));
        }
    }
    evaluateConstraint(predicates, triple, linkedShape, shape, dependencies) {
        let validConstraint = false;
        for (const predicate of predicates) {
            const constraint = predicate.constraint;
            if (constraint === undefined) {
                validConstraint = validConstraint || true;
                break;
            }
            const shapeContraintResult = this.handleShapeConstraint(constraint, triple, linkedShape, shape, dependencies);
            if (shapeContraintResult === ConstraintResult.NOT_RESPECT) {
                validConstraint = validConstraint || false;
                continue;
            }
            if (shapeContraintResult === ConstraintResult.RESPECT) {
                validConstraint = validConstraint || true;
                continue;
            }
            const typeConstraintResult = Bindings.handleShapeType(constraint, triple);
            if (typeConstraintResult === ConstraintResult.NOT_RESPECT) {
                validConstraint = validConstraint || false;
                continue;
            }
            if (typeConstraintResult === ConstraintResult.RESPECT) {
                validConstraint = validConstraint || true;
                continue;
            }
            // all the constraint are valid so we can skip the rest of the predicate with the same IRI but
            // possible different constraints.
            validConstraint = validConstraint || true;
            break;
        }
        if (validConstraint) {
            this.bindings.set(triple.predicate, triple);
            this.shapePredicateBind.set(triple.predicate, true);
        }
        else if (!this.strict && triple.isOptional === true && this.allOptional === false) {
            this.bindings.set(triple.predicate, triple);
        }
        else {
            this.unboundTriple.push(triple);
        }
    }
    fillNestedContainedStarPatternName(starPattern, cycle, originalName, rejectedValues, result) {
        for (const { dependencies } of starPattern.starPattern.values()) {
            if (dependencies !== undefined) {
                const currentBranch = result.get(starPattern.name);
                if (currentBranch !== undefined) {
                    currentBranch.push(dependencies.name);
                }
                else {
                    result.set(starPattern.name, [dependencies.name]);
                }
                if (result.has(dependencies.name)) {
                    cycle.add(dependencies.name);
                    cycle.add(starPattern.name);
                }
                // we don't make dependent star pattern directly cycled connected to the current star pattern
                if (result.has(dependencies.name) && dependencies.name === originalName) {
                    rejectedValues.add(dependencies.name);
                    rejectedValues.add(starPattern.name);
                }
                // to avoid infinite loop
                if (!cycle.has(dependencies.name)) {
                    this.fillNestedContainedStarPatternName(dependencies, cycle, originalName, rejectedValues, result);
                }
            }
        }
    }
    handleShapeConstraint(constraint, triple, linkedShape, currentShape, dependencies) {
        if (constraint.type === 0 /* ContraintType.SHAPE */ && dependencies !== undefined && constraint.value.size == 1) {
            const shapeName = constraint.value.values().next().value;
            const currentLinkedShape = currentShape.name === shapeName ? currentShape : linkedShape.get(shapeName);
            if (currentLinkedShape === undefined) {
                return ConstraintResult.RESPECT;
            }
            const nestedBinding = new Bindings(currentLinkedShape, dependencies, linkedShape, [], this.strict);
            if (nestedBinding.isFullyBounded()) {
                this.bindings.set(triple.predicate, triple);
                this.nestedContainedStarPatternNameShapesContained = new Map([
                    ...this.nestedContainedStarPatternNameShapesContained,
                    ...nestedBinding.nestedContainedStarPatternNameShapesContained
                ]);
                const dependentShape = this.nestedContainedStarPatternNameShapesContained.get(dependencies.name);
                if (dependentShape === undefined) {
                    this.nestedContainedStarPatternNameShapesContained.set(dependencies.name, [currentLinkedShape.name]);
                }
                else {
                    dependentShape.push(currentLinkedShape.name);
                }
                return ConstraintResult.RESPECT;
            }
            else {
                return ConstraintResult.NOT_RESPECT;
            }
        }
        return ConstraintResult.INAPPLICABLE;
    }
    static handleShapeType(constraint, triple) {
        if (constraint.type === 1 /* ContraintType.TYPE */ &&
            !Array.isArray(triple.object) &&
            triple.object.termType === "Literal"
            && constraint.value.has(triple.object.datatype.value)) {
            return ConstraintResult.RESPECT;
        }
        else if (constraint.type === 1 /* ContraintType.TYPE */ &&
            !Array.isArray(triple.object) &&
            triple.object.termType === "NamedNode"
            && constraint.value.has(triple.object.value)) {
            return ConstraintResult.RESPECT;
        }
        else if (constraint.type === 1 /* ContraintType.TYPE */ &&
            !Array.isArray(triple.object) &&
            triple.object.termType === "Literal"
            && !constraint.value.has(triple.object.datatype.value)) {
            return ConstraintResult.NOT_RESPECT;
        }
        else if (constraint.type === 1 /* ContraintType.TYPE */ &&
            !Array.isArray(triple.object) &&
            triple.object.termType === "NamedNode"
            && !constraint.value.has(triple.object.value)) {
            return ConstraintResult.NOT_RESPECT;
        }
        else if (constraint.type === 1 /* ContraintType.TYPE */ &&
            Array.isArray(triple.object)) {
            for (const object of triple.object) {
                if (constraint.value.has(object.value) || (object.termType === "Literal" && constraint.value.has(object.datatype.value))) {
                    return ConstraintResult.RESPECT;
                }
            }
        }
        return ConstraintResult.INAPPLICABLE;
    }
    isFullyBounded() {
        return this.fullyBounded;
    }
    getUnboundedTriple() {
        return new Array(...this.unboundTriple);
    }
    getBindings() {
        return new Map(this.bindings);
    }
    getBoundTriple() {
        const resp = [];
        for (const triple of this.bindings.values()) {
            if (triple !== undefined) {
                resp.push(triple);
            }
        }
        return resp;
    }
    shouldVisitShape() {
        return this.getBoundTriple().length > 0;
    }
    getNestedContainedStarPatternName() {
        return this.nestedContainedStarPatternName;
    }
}
exports.Bindings = Bindings;
class OneOfBinding {
    paths;
    constructor(paths) {
        this.paths = paths;
    }
    get(el) {
        const resp = [];
        for (const path of this.paths) {
            const predicate = path.get(el);
            if (predicate !== undefined) {
                resp.push(predicate);
            }
        }
        return resp.length === 0 ? undefined : resp;
    }
}
exports.OneOfBinding = OneOfBinding;
class UnionBinding {
    bindings;
    hasOneContained;
    areAllContained;
    dependentStarPattern;
    constructor(shape, union, linkedShape) {
        this.bindings = [];
        for (const starPattern of union) {
            this.bindings.push(new Bindings(shape, starPattern, linkedShape));
        }
        this.hasOneContained = this.determineHasOneAtLeastContainment();
        this.areAllContained = this.determineAllContained();
        const dependentStarPatternSet = new Map();
        for (const binding of this.bindings) {
            for (const startPattern of binding.getNestedContainedStarPatternName()) {
                dependentStarPatternSet.set(startPattern.starPattern, startPattern);
            }
        }
        this.dependentStarPattern = Array.from(dependentStarPatternSet.values());
    }
    determineHasOneAtLeastContainment() {
        let hasOneContainment = false;
        for (const binding of this.bindings) {
            hasOneContainment = hasOneContainment || binding.isFullyBounded();
        }
        return hasOneContainment;
    }
    determineAllContained() {
        let hasOneContainment = true;
        for (const binding of this.bindings) {
            hasOneContainment = hasOneContainment && binding.isFullyBounded();
        }
        return hasOneContainment;
    }
}
exports.UnionBinding = UnionBinding;
//# sourceMappingURL=Binding.js.map