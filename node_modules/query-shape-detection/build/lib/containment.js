"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContainmentResult = void 0;
exports.solveShapeQueryContainment = solveShapeQueryContainment;
const Binding_1 = require("./Binding");
const constant_1 = require("./constant");
const query_1 = require("./query");
/**
 * Determine if a query is contained inside a shape.
 * It provide detail information about the containment and weither or not
 * the documents linked with the shape should be followed.
 * @param param {IContainementArg} - the shape and the query to evaluate
 * @returns {IResult} result relative to the containement of the query inside of the shape
 */
function solveShapeQueryContainment({ query, shapes }) {
    const bindingResult = new Map();
    const starPatternsContainment = new Map();
    const queryStarPattern = new Map();
    const groupedShapes = groupShapeBydependencies(shapes);
    for (const [starPatternsName, starPatternWithDependencies] of query.starPatterns) {
        for (const { triple } of starPatternWithDependencies.starPattern.values()) {
            queryStarPattern.set(triple.toString(), triple);
        }
        starPatternsContainment.set(starPatternsName, { result: ContainmentResult.REJECTED });
    }
    // dependent, origin 
    const nestedContainedStarPatterns = new Map();
    for (const { shape, dependencies } of groupedShapes) {
        bindingResult.set(shape.name, new Map());
        const bindingResultofShape = bindingResult.get(shape.name);
        for (const [starPatternName, starPattern] of query.starPatterns) {
            const starPatternUnion = (0, query_1.generateStarPatternUnion)(query.union ?? [], starPatternName);
            const bindings = new Binding_1.Bindings(shape, starPattern, dependencies, starPatternUnion);
            const currentNestedStarPattern = bindings.getNestedContainedStarPatternName();
            for (const starPattern of currentNestedStarPattern) {
                const currentNestedContainedStarPatterns = nestedContainedStarPatterns.get(starPattern.starPattern);
                if (currentNestedContainedStarPatterns === undefined) {
                    nestedContainedStarPatterns.set(starPattern.starPattern, new Map([[starPatternName, starPattern]]));
                }
                else {
                    currentNestedContainedStarPatterns.set(starPatternName, starPattern);
                }
            }
            bindingResultofShape.set(starPatternName, { result: bindings, shape });
            for (const triple of bindings.getBoundTriple()) {
                queryStarPattern.set(triple.toString(), undefined);
            }
        }
    }
    for (const [shapeName, starPatternBinding] of bindingResult) {
        const currentShapeBindingResult = bindingResult.get(shapeName);
        for (const [starPatternName, bindingResult] of starPatternBinding) {
            const originOfDependency = nestedContainedStarPatterns.get(starPatternName);
            // validate that there are no cycles if there are cycles we analyse the star pattern independently
            for (const [origin, dependencyInfo] of originOfDependency ?? []) {
                if (!nestedContainedStarPatterns.has(origin)) {
                    currentShapeBindingResult.set(starPatternName, { ...bindingResult, dependent: dependencyInfo });
                    break;
                }
            }
        }
    }
    for (const starPatternBinding of bindingResult.values()) {
        for (const [starPatternName, result] of starPatternBinding) {
            if (result.dependent === undefined) {
                updateStarPatternContainment(starPatternsContainment, result.result, starPatternName, result.shape);
            }
            else {
                // check the shape contained related to the dependent star pattern
                const dependendShapes = [];
                for (const [shapeName, nestedBinding] of bindingResult) {
                    const nestedResult = nestedBinding.get(starPatternName);
                    if (nestedResult !== undefined) {
                        if (nestedResult.result.isFullyBounded()) {
                            dependendShapes.push(shapeName);
                        }
                    }
                }
                const constraintTarget = [];
                for (const [shapeName, nestedBinding] of bindingResult) {
                    const originBinding = nestedBinding.get(result.dependent.origin);
                    if (originBinding !== undefined) {
                        constraintTarget.push(shapeName);
                    }
                }
                // we check if there is less shapes contained than the constraint of the dependency
                const target = constraintTarget.length > dependendShapes.length
                    || constraintTarget.length === 0
                    ? dependendShapes : result.dependent.shape;
                starPatternsContainment.set(starPatternName, { result: ContainmentResult.DEPEND, target });
            }
        }
    }
    const conditionalLink = [];
    for (const triple of queryStarPattern.values()) {
        if (triple !== undefined) {
            if (!Array.isArray(triple.object) && triple.object?.termType === "NamedNode") {
                conditionalLink.push({
                    link: triple.object.value,
                    starPatternName: triple.subject
                });
            }
        }
    }
    return {
        conditionalLink: shapes.length === 0 ? [] : conditionalLink,
        starPatternsContainment,
        visitShapeBoundedResource: generateVisitStatus(bindingResult, shapes)
    };
}
function updateStarPatternContainment(starPatternsContainment, bindings, starPatternName, shape) {
    const prevContainmentResult = starPatternsContainment.get(starPatternName);
    if (bindings.shouldVisitShape() && bindings.getUnboundedTriple().length > 0 && prevContainmentResult.result !== ContainmentResult.CONTAIN) {
        const classBinding = bindings.getBindings().get(constant_1.TYPE_DEFINITION.value);
        starPatternsContainment.set(starPatternName, {
            result: ContainmentResult.ALIGNED,
            target: (prevContainmentResult.target ?? []).concat(shape.name),
            bindingByRdfClass: (prevContainmentResult.bindingByRdfClass ?? [])
                .concat(classBinding !== undefined ? shape.name : [])
        });
    }
    if (bindings.shouldVisitShape() && bindings.isFullyBounded()) {
        starPatternsContainment.set(starPatternName, {
            result: ContainmentResult.CONTAIN,
            target: prevContainmentResult.result === ContainmentResult.ALIGNED ? [shape.name] :
                (prevContainmentResult.target ?? []).concat(shape.name)
        });
    }
}
function groupShapeBydependencies(shapes, dependentShapes) {
    const resp = [];
    for (let i = 0; i < shapes.length; i++) {
        const target = shapes[i];
        const others = new Map(shapes.slice(0, i).concat(shapes.slice(i + 1)).concat(dependentShapes ?? []).map((shape) => [shape.name, shape]));
        resp.push({
            shape: target,
            dependencies: others
        });
    }
    return resp;
}
function generateVisitStatus(bindings, shapes) {
    const visitShapeBoundedResource = new Map();
    for (const shape of shapes) {
        visitShapeBoundedResource.set(shape.name, false);
    }
    for (const [shapeName, starPatternBindings] of bindings) {
        for (const bindingShape of starPatternBindings.values()) {
            if (bindingShape !== undefined) {
                const previousStatus = visitShapeBoundedResource.get(shapeName);
                const currentStatus = bindingShape.result.shouldVisitShape();
                if (previousStatus === false && currentStatus === true) {
                    visitShapeBoundedResource.set(shapeName, true);
                }
            }
        }
    }
    return visitShapeBoundedResource;
}
/**
 * The result of a containement
 */
var ContainmentResult;
(function (ContainmentResult) {
    // Is contained
    ContainmentResult[ContainmentResult["CONTAIN"] = 0] = "CONTAIN";
    // Has at least one binding
    ContainmentResult[ContainmentResult["ALIGNED"] = 1] = "ALIGNED";
    // Is a dependency of a contained star pattern
    ContainmentResult[ContainmentResult["DEPEND"] = 2] = "DEPEND";
    // Has no binding
    ContainmentResult[ContainmentResult["REJECTED"] = 3] = "REJECTED";
})(ContainmentResult || (exports.ContainmentResult = ContainmentResult = {}));
//# sourceMappingURL=containment.js.map